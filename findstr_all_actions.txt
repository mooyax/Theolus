src\Unit.js:8:    static assets = {
src\Unit.js:13:    static nextId = 0;
src\Unit.js:20:        const bodyGeo = new THREE.BoxGeometry(0.3, 0.35, 0.2);
src\Unit.js:22:        Unit.assets.geometries.body = bodyGeo;
src\Unit.js:24:        const headGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
src\Unit.js:26:        Unit.assets.geometries.head = headGeo;
src\Unit.js:29:        const faceGeo = new THREE.PlaneGeometry(0.2, 0.2);
src\Unit.js:30:        faceGeo.translate(0, 0.6, 0.126); // Slightly in front of Head Box (Z=0.125)
src\Unit.js:31:        Unit.assets.geometries.facePlane = faceGeo;
src\Unit.js:33:        const limbGeo = new THREE.BoxGeometry(0.1, 0.25, 0.1);
src\Unit.js:35:        Unit.assets.geometries.limb = limbGeo;
src\Unit.js:39:        const swordGeo = new THREE.BoxGeometry(0.05, 0.5, 0.05);
src\Unit.js:41:        Unit.assets.geometries.sword = swordGeo;
src\Unit.js:44:        const staffGeo = new THREE.BoxGeometry(0.05, 0.8, 0.05);
src\Unit.js:46:        Unit.assets.geometries.staff = staffGeo;
src\Unit.js:50:        const brimGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.02, 16);
src\Unit.js:53:        const coneGeo = new THREE.ConeGeometry(0.15, 0.4, 16);
src\Unit.js:71:        const hatGeo = new THREE.ConeGeometry(0.2, 0.5, 16);
src\Unit.js:73:        Unit.assets.geometries.wizardHat = hatGeo;
src\Unit.js:76:        const hatBrimGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.02, 16);
src\Unit.js:77:        Unit.assets.geometries.wizardHatBrim = hatBrimGeo;
src\Unit.js:80:        const indicatorTopGeo = new THREE.CylinderGeometry(0.04, 0.02, 0.25, 8);
src\Unit.js:82:        Unit.assets.geometries.jobIndicatorTop = indicatorTopGeo;
src\Unit.js:84:        const indicatorDotGeo = new THREE.SphereGeometry(0.04, 8, 8);
src\Unit.js:86:        Unit.assets.geometries.jobIndicatorDot = indicatorDotGeo;
src\Unit.js:90:        Unit.assets.materials.skin = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.8 });
src\Unit.js:91:        Unit.assets.materials.clothes = new THREE.MeshStandardMaterial({ color: 0x885533, roughness: 1.0 });
src\Unit.js:92:        Unit.assets.materials.tool = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 });
src\Unit.js:93:        Unit.assets.materials.hat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 1.0 });
src\Unit.js:96:        Unit.assets.materials.armor = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
src\Unit.js:97:        Unit.assets.materials.helmet = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 });
src\Unit.js:101:        Unit.assets.materials.robe = new THREE.MeshStandardMaterial({ color: 0x444499, roughness: 1.0 });
src\Unit.js:102:        Unit.assets.materials.wizardHat = new THREE.MeshStandardMaterial({ color: 0x333388, roughness: 1.0 });
src\Unit.js:105:        Unit.assets.materials.metal = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, metalness: 0.9, roughness: 0.2 });
src\Unit.js:106:        Unit.assets.materials.wood = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
src\Unit.js:107:        Unit.assets.materials.darkMagic = new THREE.MeshStandardMaterial({ color: 0x330033, roughness: 1.0 });
src\Unit.js:110:        Unit.assets.materials.redIndicator = new THREE.MeshStandardMaterial({
src\Unit.js:119:        Unit.assets.textures.face = Unit.createFaceTexture();
src\Unit.js:120:        Unit.assets.materials.face = new THREE.MeshStandardMaterial({ map: Unit.assets.textures.face, transparent: true });
src\Unit.js:122:        Unit.assets.textures.hair = Unit.createHairTexture();
src\Unit.js:124:        Unit.assets.materials.hair = new THREE.MeshLambertMaterial({ map: Unit.assets.textures.hair, transparent: true });
src\Unit.js:126:        Unit.assets.materials.heads = null; // Deprecated (Split meshes)
src\Unit.js:128:        Unit.assets.initialized = true;
src\Unit.js:132:        const canvas = document.createElement('canvas');
src\Unit.js:133:        canvas.width = 64;
src\Unit.js:134:        canvas.height = 64;
src\Unit.js:135:        const ctx = canvas.getContext('2d');
src\Unit.js:136:        ctx.fillStyle = '#FFCCAA'; ctx.fillRect(0, 0, 64, 64);
src\Unit.js:137:        ctx.fillStyle = '#4A3000'; ctx.fillRect(0, 0, 64, 15);
src\Unit.js:138:        ctx.fillStyle = '#000000'; ctx.fillRect(15, 25, 8, 8); ctx.fillRect(41, 25, 8, 8);
src\Unit.js:139:        ctx.fillStyle = '#A0522D'; ctx.fillRect(20, 45, 24, 4);
src\Unit.js:144:        const canvas = document.createElement('canvas');
src\Unit.js:145:        canvas.width = 64;
src\Unit.js:146:        canvas.height = 64;
src\Unit.js:147:        const ctx = canvas.getContext('2d');
src\Unit.js:149:        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, 64, 64); // White Base
src\Unit.js:150:        ctx.fillStyle = '#DDDDDD'; // Very Light Grey Noise
src\Unit.js:151:        for (let i = 0; i < 40; i++) {
src\Unit.js:157:    constructor(scene, terrain, x, z, role, isSpecial = false, squadId = null) {
src\Unit.js:162:        // Let's use Base ID. BUT Unit has static nextId=0. 
src\Unit.js:171:        this.id = Unit.nextId++;
src\Unit.js:174:        this.gridX = (x !== undefined) ? x : 20;
src\Unit.js:175:        this.gridZ = (z !== undefined) ? z : 20;
src\Unit.js:179:        let specialFlag = isSpecial;
src\Unit.js:180:        if (typeof role === 'boolean') {
src\Unit.js:181:            specialFlag = role;
src\Unit.js:182:            role = 'worker';
src\Unit.js:185:        this.role = role || 'worker';
src\Unit.js:186:        this.role = role || 'worker';
src\Unit.js:187:        this.isSpecial = specialFlag;
src\Unit.js:188:        this.squadId = squadId; // Squad ID for coordinated attacks
src\Unit.js:190:        this.lastGridX = this.gridX;
src\Unit.js:191:        this.lastGridZ = this.gridZ;
src\Unit.js:192:        this.lastGridX = this.gridX;
src\Unit.js:193:        this.lastGridZ = this.gridZ;
src\Unit.js:194:        this.stagnationTimer = 0;
src\Unit.js:195:        this.buildStagnationCount = 0;
src\Unit.js:196:        this.lastTime = 0; // Fix: Undefined caused logic failure
src\Unit.js:197:        this.lastGatherTime = -Math.random() * 30; // Stagger gathering
src\Unit.js:200:        this.position = new THREE.Vector3();
src\Unit.js:201:        this.rotationY = 0;
src\Unit.js:202:        this.limbs = {
src\Unit.js:212:        // Special Unit = 6-9 mins.
src\Unit.js:214:        // Aging Rate remains same (Worker=1yr/s, Soldier=1yr/10s).
src\Unit.js:215:        const baseLifespan = 80 + Math.random() * 20;
src\Unit.js:216:        this.lifespan = baseLifespan;
src\Unit.js:218:        this.age = 20; // Starts at 20 years old
src\Unit.js:219:        this.isSleeping = false;
src\Unit.js:220:        this.isNight = false; // Sync flag for states
src\Unit.js:221:        this.isDead = false;
src\Unit.js:222:        this.isMoving = false; // Entity base normally sets this, but be sure
src\Unit.js:223:        this.debugFrame = 0; // Initialize for logic gatesr)
src\Unit.js:224:        this.hp = 35 + Math.floor(Math.random() * 15); // Nerfed (Avg 42)
src\Unit.js:225:        this.maxHp = this.hp;
src\Unit.js:226:        this.attackCooldown = 0;
src\Unit.js:227:        this.attackRate = 1.0;
src\Unit.js:228:        this.damage = 4; // Nerfed (Goblin has 30HP -> 8 hits)
src\Unit.js:229:        this.targetGoblin = null;
src\Unit.js:232:        if (this.role === 'knight') {
src\Unit.js:233:            this.hp *= 15; // Massive HP (40x15 = 600) - Overwhelming
src\Unit.js:234:            this.maxHp = this.hp;
src\Unit.js:235:            this.damage *= 25; // 100 Dmg (Definitely 1-shot Normal Goblin)
src\Unit.js:236:        } else if (this.role === 'wizard') {
src\Unit.js:237:            this.hp *= 3; // Buffed (40x3 = 120) - Strong enough to survive
src\Unit.js:238:            this.maxHp = this.hp;
src\Unit.js:239:            this.damage *= 20; // 80 Dmg (1-shot Normal, 2-shot Hob)
src\Unit.js:240:            this.attackRate = 2.0; // Slower attack? Or faster? "Multi-target"
src\Unit.js:246:        this.moveTimer = 0;
src\Unit.js:247:        this.moveDuration = 1000;
src\Unit.js:248:        this.moveStartTime = 0;
src\Unit.js:249:        this.startGridX = 0;
src\Unit.js:250:        this.startGridZ = 0;
src\Unit.js:251:        this.targetGridX = 0;
src\Unit.js:252:        this.targetGridZ = 0;
src\Unit.js:255:        this.ignoredTargets = new Map(); // id -> expiryTime
src\Unit.js:258:        this.lastTime = 0;
src\Unit.js:260:        this.moveInterval = 2000 + Math.random() * 3000;
src\Unit.js:261:        if (this.role === 'knight' || this.role === 'wizard') {
src\Unit.js:262:            this.moveInterval = 0; // Soldiers act immediately on spawn
src\Unit.js:265:        this.stagnationTimer = 0;
src\Unit.js:266:        this.huntingCooldown = 0;
src\Unit.js:267:        this.target = null; // Assuming 'Target' was a typo for 'this.target'
src\Unit.js:270:        this.targetX = 0;
src\Unit.js:271:        this.targetZ = 0;
src\Unit.js:275:        if (typeof UnitWanderState !== 'undefined') {
src\Unit.js:284:        // this.moveStartTime = 0; // Already defined above
src\Unit.js:285:        // this.moveDuration = 1000; // Already defined above
src\Unit.js:293:        this.wanderCount = 0;
src\Unit.js:294:        this.migrationTarget = null;
src\Unit.js:297:        this.ignoredTargets = new Map(); // id -> timestamp until ignored
src\Unit.js:298:        this.debugFrame = 0;
src\Unit.js:304:        this.hp -= amount;
src\Unit.js:305:        if (isNaN(this.hp)) this.hp = 0;
src\Unit.js:307:        if (this.hp <= 0) {
src\Unit.js:308:            this.hp = 0;
src\Unit.js:312:            // Hit Flash / Reaction
src\Unit.js:313:            this.lastHitTime = this.simTime || 0;
src\Unit.js:318:                this.targetGoblin = attacker;
src\Unit.js:325:        this.isDead = true;
src\Unit.js:330:        const g = this.game || window.game;
src\Unit.js:332:            console.log(`[Unit ${this.id}] Releasing request via ${g === this.game ? 'this.game' : 'window.game'}`);
src\Unit.js:334:            this.targetRequest = null;
src\Unit.js:348:            this.targetGoblin = null;
src\Unit.js:353:        if (this.role === 'wizard') {
src\Unit.js:355:            this.limbs.leftArm.x = -Math.PI; // Raise staff
src\Unit.js:356:            this.limbs.rightArm.x = -Math.PI;
src\Unit.js:360:                const startPos = this.position.clone().add(new THREE.Vector3(0, 0.9, 0)); // Head/Staff level
src\Unit.js:363:                const h = this.terrain.getTileHeight(goblin.gridX, goblin.gridZ);
src\Unit.js:366:                const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:367:                const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:371:                const targetPos = new THREE.Vector3(
src\Unit.js:380:            setTimeout(() => {
src\Unit.js:382:                    this.limbs.leftArm.x = 0;
src\Unit.js:383:                    this.limbs.rightArm.x = 0;
src\Unit.js:388:            this.limbs.rightArm.x = -Math.PI / 2;
src\Unit.js:389:            setTimeout(() => {
src\Unit.js:390:                if (!this.isDead) this.limbs.rightArm.x = 0;
src\Unit.js:398:        if (this.role === 'knight' || this.role === 'wizard') {
src\Unit.js:402:        if (goblin.hp <= 0) {
src\Unit.js:403:            goblin.isDead = true;
src\Unit.js:404:            this.targetGoblin = null;
src\Unit.js:406:            if (window.game && (this.role === 'knight' || this.role === 'wizard')) {
src\Unit.js:411:        this.attackCooldown = this.attackRate;
src\Unit.js:418:        const damage = (damageOverride !== undefined) ? damageOverride : (this.damage || 10);
src\Unit.js:421:        if (this.role === 'wizard') {
src\Unit.js:422:            this.limbs.leftArm.x = -Math.PI;
src\Unit.js:423:            this.limbs.rightArm.x = -Math.PI;
src\Unit.js:424:            setTimeout(() => {
src\Unit.js:426:                    this.limbs.leftArm.x = 0;
src\Unit.js:427:                    this.limbs.rightArm.x = 0;
src\Unit.js:431:            this.limbs.rightArm.x = -Math.PI / 2;
src\Unit.js:432:            setTimeout(() => {
src\Unit.js:433:                if (!this.isDead) this.limbs.rightArm.x = 0;
src\Unit.js:437:        const bType = building.userData.type;
src\Unit.js:440:        if (bType === 'farm') {
src\Unit.js:442:            if (building.userData.hp === undefined) building.userData.hp = 5;
src\Unit.js:444:            if (building.userData.hp > 5) building.userData.hp = 5;
src\Unit.js:446:            building.userData.hp -= damage;
src\Unit.js:449:            if (building.userData.hp <= 0) {
src\Unit.js:452:                this.targetBuilding = null;
src\Unit.js:456:        // --- POPULATED BUILDING LOGIC (Pop = HP + Counter Attack) ---
src\Unit.js:457:        else if (bType === 'house' || bType === 'mansion' || bType === 'castle' || bType === 'tower' || bType === 'barracks') {
src\Unit.js:461:            let pop = building.userData.population || 0;
src\Unit.js:463:            if (pop <= 0) {
src\Unit.js:467:                this.targetBuilding = null;
src\Unit.js:469:                this.attackCooldown = this.attackRate;
src\Unit.js:473:            // Damage formulation: 1 Damage = 1 Population ?
src\Unit.js:475:            // Direct subtraction seems fair.
src\Unit.js:477:            building.userData.population -= Math.ceil(damage / 2); // Halve damage so populations last a bit longer?
src\Unit.js:482:            building.population = building.userData.population;
src\Unit.js:486:            if (building.userData.population <= 0) {
src\Unit.js:489:                this.targetBuilding = null;
src\Unit.js:494:                let retaliationFactor = 0.5; // Default (House/Worker)
src\Unit.js:496:                if (bType === 'tower') retaliationFactor = 2.0; // Wizards (Strong)
src\Unit.js:497:                if (bType === 'barracks') retaliationFactor = 1.5; // Knights (Medium-Strong)
src\Unit.js:498:                if (bType === 'castle') retaliationFactor = 2.0; // Elite
src\Unit.js:501:                // Cap effective output to avoid 1-shotting the attacker instantly if pop is huge (100 pop * 2 = 200 dmg!)
src\Unit.js:504:                // Let's dampen slightly: damage = sqrt(pop) * factor?
src\Unit.js:508:                const retaliationDamage = Math.floor(pop * retaliationFactor * 0.5);
src\Unit.js:519:            if (building.userData.hp === undefined) {
src\Unit.js:520:                building.userData.hp = (building.userData.type === 'cave' ? 200 : 100);
src\Unit.js:522:            building.userData.hp -= damage;
src\Unit.js:525:            if (building.userData.hp <= 0) {
src\Unit.js:527:                this.targetBuilding = null;
src\Unit.js:532:        this.attackCooldown = this.attackRate;
src\Unit.js:551:        let bestTarget = null;
src\Unit.js:552:        let bestScore = Infinity; // Lower is better
src\Unit.js:555:        const hasValidGoblin = this.targetGoblin && !this.targetGoblin.isDead;
src\Unit.js:556:        const hasValidBuilding = this.targetBuilding && this.targetBuilding.userData && this.targetBuilding.userData.hp > 0;
src\Unit.js:558:        let isBusy = (this.action === 'Chasing' || this.action === 'Fighting' || this.action === 'Sieging' || this.action === 'Unstuck' || this.action === 'Reinforcing');
src\Unit.js:561:        if (this.role === 'worker' && this.targetRequest) isBusy = true;
src\Unit.js:563:        this.scanTimer = (this.scanTimer || 0) + 1;
src\Unit.js:566:        let scanInterval = 30;
src\Unit.js:568:            scanInterval = 300; // 5 seconds commitment
src\Unit.js:571:        const forceScan = (this.scanTimer > scanInterval);
src\Unit.js:574:        let shouldScan = (!isBusy || (!hasValidGoblin && !hasValidBuilding) || forceScan);
src\Unit.js:575:        if (this.role === 'worker' && this.targetRequest) shouldScan = false;
src\Unit.js:578:        if ((this.action === 'Reinforcing' || this.action === 'Migrating' || this.migrationTarget) && !forceScan) return false;
src\Unit.js:582:        const frame = (window.game && window.game.frameCounter) ? window.game.frameCounter : 0;
src\Unit.js:583:        if (!forceScan && (frame + this.id) % 20 !== 0) {
src\Unit.js:586:            if ((this.role === 'knight' || this.role === 'wizard') && (frame + this.id) % 10 !== 0) {
src\Unit.js:588:            } else if (this.role === 'worker') {
src\Unit.js:599:            if (forceScan) this.scanTimer = 0;
src\Unit.js:602:            const currentTargetId = this.targetGoblin ? this.targetGoblin.id :
src\Unit.js:606:            const goblins = passedGoblins || (window.game && window.game.goblinManager ? window.game.goblinManager.goblins : []);
src\Unit.js:610:                const maxDist = (this.role === 'knight' || this.role === 'wizard') ? 50 : 15;
src\Unit.js:616:                    const d = this.getDistance(g.gridX, g.gridZ);
src\Unit.js:619:                    const myRegion = (this.terrain.grid[this.gridX] && this.terrain.grid[this.gridX][this.gridZ]) ? this.terrain.grid[this.gridX][this.gridZ].regionId : 1;
src\Unit.js:620:                    const gRegion = (this.terrain.grid[g.gridX] && this.terrain.grid[g.gridX][g.gridZ]) ? this.terrain.grid[g.gridX][g.gridZ].regionId : 1;
src\Unit.js:622:                    if (myRegion !== gRegion) {
src\Unit.js:627:                    let limit = maxDist;
src\Unit.js:628:                    if (g.id === currentTargetId) limit = maxDist * 2.0;
src\Unit.js:633:                    const myH = this.terrain.getTileHeight(this.gridX, this.gridZ);
src\Unit.js:634:                    const targetH = this.terrain.getTileHeight(g.gridX, g.gridZ);
src\Unit.js:637:                    let h = 0;
src\Unit.js:639:                    if (this.terrain.getTileHeight) h = this.terrain.getTileHeight(g.gridX, g.gridZ);
src\Unit.js:641:                    let score = d - 1000.0; // Base priority for Goblins (High)
src\Unit.js:642:                    if (h > 8) score += 20;
src\Unit.js:645:                    if (g.id === currentTargetId) score -= 500.0;
src\Unit.js:648:                        bestScore = score;
src\Unit.js:649:                        bestTarget = { type: 'goblin', obj: g };
src\Unit.js:656:                const range = (this.role === 'knight' || this.role === 'wizard') ? Infinity : 10;
src\Unit.js:658:                    if (this.role === 'worker' && b.userData.type !== 'goblin_hut' && b.userData.type !== 'cave') continue;
src\Unit.js:659:                    if (b.userData.type === 'goblin_hut' || b.userData.type === 'cave') {
src\Unit.js:660:                        if (b.userData && b.userData.hp <= 0) continue;
src\Unit.js:662:                        const d = this.getDistance(b.gridX, b.gridZ);
src\Unit.js:665:                        let score = d - 5.0; // Lower priority than goblins (-1000)
src\Unit.js:666:                        if (b.id === currentTargetId) score -= 500.0; // Sticky Bonus
src\Unit.js:668:                        if (d < 8.0 && (this.role === 'knight' || this.role === 'wizard')) score -= 2000.0; // Sieging Logic Override
src\Unit.js:671:                            bestScore = score;
src\Unit.js:672:                            bestTarget = { type: 'building', obj: b };
src\Unit.js:679:            this.targetGoblin = null;
src\Unit.js:680:            this.targetBuilding = null;
src\Unit.js:683:                if (bestTarget.type === 'goblin') this.targetGoblin = bestTarget.obj;
src\Unit.js:684:                else this.targetBuilding = bestTarget.obj;
src\Unit.js:688:            const hasRaidTarget = this.findRaidTarget();
src\Unit.js:692:                const d = this.getDistance(this.targetGoblin.gridX, this.targetGoblin.gridZ);
src\Unit.js:694:                    this.targetGoblin = null;
src\Unit.js:715:        const buildings = this.terrain.buildings;
src\Unit.js:716:        let nearest = null;
src\Unit.js:717:        let minDist = Infinity; // Global Search (Soldiers travel far)
src\Unit.js:718:        let foundType = null;
src\Unit.js:720:        const limitRange = (range !== undefined) ? range : Infinity;
src\Unit.js:725:            if (this.role === 'worker' && b.type !== 'goblin_hut') continue;
src\Unit.js:727:            if (b.type === 'goblin_hut' || b.type === 'cave') {
src\Unit.js:728:                const dist = this.getDistance(b.gridX, b.gridZ);
src\Unit.js:734:                    minDist = dist;
src\Unit.js:735:                    nearest = b;
src\Unit.js:736:                    foundType = b.type;
src\Unit.js:742:        if (this.role === 'knight' && Math.random() < 0.001) {
src\Unit.js:748:            this.targetBuilding = nearest;
src\Unit.js:756:        const x = target.gridX;
src\Unit.js:757:        const z = target.gridZ;
src\Unit.js:777:            const squad = window.game.getSquad(this.squadId);
src\Unit.js:781:                const now = window.game.simTotalTimeSec || 0;
src\Unit.js:782:                const age = now - squad.target.time;
src\Unit.js:785:                if (Math.random() < 0.05 && this.role === 'knight') {
src\Unit.js:786:                    const d = this.getDistance(squad.target.x, squad.target.z);
src\Unit.js:792:                    const d = this.getDistance(squad.target.x, squad.target.z);
src\Unit.js:797:                            this.targetRaidPoint = { x: squad.target.x, z: squad.target.z };
src\Unit.js:802:                            const myCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:804:                                const proxy = this.terrain.findClosestReachablePoint(squad.target.x, squad.target.z, myCell.regionId);
src\Unit.js:807:                                    this.targetRaidPoint = { x: proxy.x, z: proxy.z };
src\Unit.js:819:        if ((this.role === 'knight' || this.role === 'wizard') && window.game && window.game.battleHotspots && window.game.battleHotspots.length > 0) {
src\Unit.js:820:            const now = window.game.simTotalTimeSec || 0;
src\Unit.js:822:            let bestSpot = null;
src\Unit.js:823:            let minD = Infinity;
src\Unit.js:828:                let targetX = spot.x;
src\Unit.js:829:                let targetZ = spot.z;
src\Unit.js:830:                let d = this.getDistance(targetX, targetZ);
src\Unit.js:835:                    let proxyFound = false;
src\Unit.js:836:                    const myCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:838:                        const proxy = this.terrain.findClosestReachablePoint(targetX, targetZ, myCell.regionId);
src\Unit.js:840:                            targetX = proxy.x;
src\Unit.js:841:                            targetZ = proxy.z;
src\Unit.js:842:                            d = this.getDistance(targetX, targetZ);
src\Unit.js:843:                            proxyFound = true;
src\Unit.js:852:                    minD = d;
src\Unit.js:853:                    bestSpot = { x: targetX, z: targetZ };
src\Unit.js:858:                this.targetRaidPoint = { x: bestSpot.x, z: bestSpot.z };
src\Unit.js:864:        let memories = [];
src\Unit.js:865:        const currentTime = (this.game) ? this.game.simTotalTimeSec : 0;
src\Unit.js:868:            memories = this.game.battleMemory.getPriorities(currentTime);
src\Unit.js:871:        if (!memories || memories.length === 0) {
src\Unit.js:875:        let nearest = null;
src\Unit.js:876:        let minDist = Infinity;
src\Unit.js:878:        memories.forEach(p => {
src\Unit.js:879:            let targetX = p.x;
src\Unit.js:880:            let targetZ = p.z;
src\Unit.js:881:            let dist = this.getDistance(targetX, targetZ);
src\Unit.js:893:                const W = this.terrain.logicalWidth || 80;
src\Unit.js:894:                const D = this.terrain.logicalDepth || 80;
src\Unit.js:897:                let px = Math.round(targetX);
src\Unit.js:898:                let pz = Math.round(targetZ);
src\Unit.js:899:                px = ((px % W) + W) % W;
src\Unit.js:900:                pz = ((pz % D) + D) % D;
src\Unit.js:902:                const mCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:903:                const tCell = (this.terrain.grid[px]) ? this.terrain.grid[px][pz] : null;
src\Unit.js:905:                if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
src\Unit.js:907:                    const proxy = this.terrain.findClosestReachablePoint(targetX, targetZ, mCell.regionId);
src\Unit.js:909:                        targetX = proxy.x;
src\Unit.js:910:                        targetZ = proxy.z;
src\Unit.js:911:                        dist = this.getDistance(targetX, targetZ);
src\Unit.js:919:                minDist = dist;
src\Unit.js:920:                nearest = { x: targetX, z: targetZ };
src\Unit.js:925:            this.targetRaidPoint = nearest;
src\Unit.js:934:        let nearest = null;
src\Unit.js:935:        let minDist = Infinity;
src\Unit.js:942:            if (b.type === 'house' || b.type === 'castle') {
src\Unit.js:944:                    const d = this.getDistance(b.gridX, b.gridZ);
src\Unit.js:946:                        minDist = d;
src\Unit.js:947:                        nearest = b;
src\Unit.js:959:        const dist = this.getDistance(this.targetRaidPoint.x, this.targetRaidPoint.z);
src\Unit.js:960:        if (dist <= 2.0) { // Standardized to 2.0 (was 3.0)
src\Unit.js:974:                this.targetRaidPoint = null;
src\Unit.js:984:        if (this.role === 'worker' && this.targetRequest) return;
src\Unit.js:988:        const frame = (window.game && window.game.frameCounter) ? window.game.frameCounter : 0;
src\Unit.js:989:        if ((frame + this.id + 5) % 20 !== 0) {
src\Unit.js:992:            if ((this.role === 'knight' || this.role === 'wizard') && (frame + this.id + 5) % 10 !== 0) {
src\Unit.js:994:            } else if (this.role === 'worker') {
src\Unit.js:1000:        const goblinCandidates = goblins || (window.game && window.game.goblinManager ? window.game.goblinManager.goblins : []);
src\Unit.js:1005:            const range = (this.role === 'knight' || this.role === 'wizard') ? 50 : 12;
src\Unit.js:1007:            const goblin = this.terrain.findBestTarget('goblin', x, z, range, (g, dist) => {
src\Unit.js:1008:                const now = window.game ? window.game.gameTotalTime : Date.now();
src\Unit.js:1011:                const isVeryClose = (dist < 5.0);
src\Unit.js:1020:                const myH = this.terrain.getTileHeight(this.gridX, this.gridZ);
src\Unit.js:1021:                const targetH = this.terrain.getTileHeight(g.gridX, g.gridZ);
src\Unit.js:1026:                    const mCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1027:                    const tCell = this.terrain.grid[g.gridX][g.gridZ];
src\Unit.js:1028:                    if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
src\Unit.js:1035:                    const mCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1036:                    const tCell = this.terrain.grid[g.gridX][g.gridZ];
src\Unit.js:1037:                    if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
src\Unit.js:1046:                this.targetGoblin = goblin;
src\Unit.js:1054:            const building = this.terrain.findBestTarget('building', x, z, 25, (b, dist) => {
src\Unit.js:1055:                const now = window.game ? window.game.gameTotalTime : Date.now();
src\Unit.js:1056:                const id = b.userData ? (b.userData.id || b.id) : b.id;
src\Unit.js:1059:                if (b.userData.type === 'goblin_hut' || b.userData.type === 'cave') {
src\Unit.js:1062:                        const mCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1063:                        const tCell = this.terrain.grid[b.gridX][b.gridZ];
src\Unit.js:1064:                        if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
src\Unit.js:1075:                this.targetBuilding = building;
src\Unit.js:1090:            const r = Math.floor(Math.random() * this.terrain.buildings.length);
src\Unit.js:1091:            const b = this.terrain.buildings[r];
src\Unit.js:1097:            const dx = Math.abs(this.gridX - b.gridX);
src\Unit.js:1098:            const dz = Math.abs(this.gridZ - b.gridZ);
src\Unit.js:1116:        this.limbs.leftArm.x = 0;
src\Unit.js:1117:        this.limbs.rightArm.x = 0;
src\Unit.js:1118:        this.limbs.leftLeg.x = 0;
src\Unit.js:1119:        this.limbs.rightLeg.x = 0;
src\Unit.js:1121:        const built = this.tryBuildStructure(time);
src\Unit.js:1124:            if (this.action === 'Migrating') {
src\Unit.js:1126:                this.action = 'Idle';
src\Unit.js:1127:                this.migrationTarget = null;
src\Unit.js:1128:                this.migrationTimer = 0;
src\Unit.js:1129:            } else if (this.action === 'Going to Work' || this.action === 'Approaching Job') {
src\Unit.js:1132:            this.buildStagnationCount = 0;
src\Unit.js:1134:            // Check based on Target presence, not Action string (since executeMove overwrites action)
src\Unit.js:1136:                if (this.role === 'worker') {
src\Unit.js:1143:                        this.action = 'Idle';
src\Unit.js:1149:                    this.action = 'Idle';
src\Unit.js:1150:                    this.migrationTarget = null;
src\Unit.js:1152:                this.buildStagnationCount = 0;
src\Unit.js:1156:                this.buildStagnationCount = (this.buildStagnationCount || 0) + 1;
src\Unit.js:1160:                    this.buildStagnationCount = 0;
src\Unit.js:1164:                this.buildStagnationCount = 0;
src\Unit.js:1171:        const limbAngle = Math.sin(progress * Math.PI * 4) * 0.5;
src\Unit.js:1172:        this.limbs.leftArm.x = limbAngle;
src\Unit.js:1173:        this.limbs.rightArm.x = -limbAngle;
src\Unit.js:1174:        this.limbs.leftLeg.x = -limbAngle;
src\Unit.js:1175:        this.limbs.rightLeg.x = limbAngle;
src\Unit.js:1180:            if (this.rotationY !== undefined) this.mesh.rotation.y = this.rotationY;
src\Unit.js:1187:        const moved = this.smartMove(tx, tz, time);
src\Unit.js:1191:            this.stuckCount = 0;
src\Unit.js:1196:                this.stuckCount = (this.stuckCount || 0) + 1;
src\Unit.js:1208:        const time = (window.game) ? window.game.gameTotalTime : 0;
src\Unit.js:1211:        this.path = null;
src\Unit.js:1214:        const ignoreDuration = time + 5000;
src\Unit.js:1218:            this.targetGoblin = null;
src\Unit.js:1223:            this.targetBuilding = null;
src\Unit.js:1227:            this.targetRaidPoint = null;
src\Unit.js:1230:        this.stuckCount = 0;
src\Unit.js:1231:        this.action = "Idle";
src\Unit.js:1232:        this.isMoving = false;
src\Unit.js:1239:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1240:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1244:        let checkX = x;
src\Unit.js:1245:        let checkZ = z;
src\Unit.js:1246:        if (checkX < 0) checkX = logicalW - 1;
src\Unit.js:1247:        if (checkX >= logicalW) checkX = 0;
src\Unit.js:1248:        if (checkZ < 0) checkZ = logicalD - 1;
src\Unit.js:1249:        if (checkZ >= logicalD) checkZ = 0;
src\Unit.js:1252:        const currentHeight = this.terrain.getTileHeight(this.gridX, this.gridZ);
src\Unit.js:1253:        const targetHeight = this.terrain.getTileHeight(checkX, checkZ);
src\Unit.js:1255:        if (targetHeight <= 0) {
src\Unit.js:1256:            const now = (this.game) ? this.game.gameTotalTime : Date.now();
src\Unit.js:1259:                this.lastWaterLogTime = now;
src\Unit.js:1276:        const col = this.terrain.grid[checkX];
src\Unit.js:1278:        const cell = col[checkZ];
src\Unit.js:1299:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1300:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1301:        if (nextX < 0) nextX = logicalW - 1;
src\Unit.js:1302:        if (nextX >= logicalW) nextX = 0;
src\Unit.js:1303:        if (nextZ < 0) nextZ = logicalD - 1;
src\Unit.js:1304:        if (nextZ >= logicalD) nextZ = 0;
src\Unit.js:1308:        // Protect specific actions (Migrating, Reinforcing, Job-related, etc.)
src\Unit.js:1309:        const protectedActions = ["Migrating", "Reinforcing", "Going to Work", "Approaching Job", "Working", "Harvesting", "Fighting", "Sieging", "Chasing"];
src\Unit.js:1312:        // Never overwrite Job/Combat specific action strings.
src\Unit.js:1314:        if (!this.action || this.action === "Idle" || this.action === "Wandering" || this.action === "Patrolling") {
src\Unit.js:1315:            this.action = "Moving";
src\Unit.js:1319:        const currentHeight = this.terrain.getTileHeight(this.gridX, this.gridZ);
src\Unit.js:1320:        const targetHeight = this.terrain.getTileHeight(nextX, nextZ);
src\Unit.js:1321:        const heightDiff = Math.abs(targetHeight - currentHeight);
src\Unit.js:1326:        let base = 0.8;
src\Unit.js:1327:        if (targetHeight > 8) base += 2.0;
src\Unit.js:1333:        let startX = this.gridX;
src\Unit.js:1334:        let startZ = this.gridZ;
src\Unit.js:1337:            const progress = (time - this.moveStartTime) / this.moveDuration;
src\Unit.js:1339:            const p = Math.max(0, Math.min(1, progress));
src\Unit.js:1342:            let sx = this.startGridX;
src\Unit.js:1343:            let sz = this.startGridZ;
src\Unit.js:1344:            let tx = this.targetGridX;
src\Unit.js:1345:            let tz = this.targetGridZ; // Use actual memory targets
src\Unit.js:1348:            if (tx - sx > logicalW / 2) sx += logicalW;
src\Unit.js:1349:            if (sx - tx > logicalW / 2) sx -= logicalW;
src\Unit.js:1350:            if (tz - sz > logicalD / 2) sz += logicalD;
src\Unit.js:1351:            if (sz - tz > logicalD / 2) sz -= logicalD;
src\Unit.js:1353:            startX = sx + (tx - sx) * p;
src\Unit.js:1354:            startZ = sz + (tz - sz) * p;
src\Unit.js:1357:        let dx = Math.abs(nextX - startX);
src\Unit.js:1358:        let dz = Math.abs(nextZ - startZ);
src\Unit.js:1359:        if (dx > logicalW / 2) dx = logicalW - dx; // Wrap logic
src\Unit.js:1360:        if (dz > logicalD / 2) dz = logicalD - dz;
src\Unit.js:1361:        const dist2D = Math.sqrt(dx * dx + dz * dz);
src\Unit.js:1365:        this.moveDuration = (base * Math.max(0.1, dist2D)) + (heightDiff * 1.0);
src\Unit.js:1368:        this.stuckCount = 0;
src\Unit.js:1373:        this.lastGatherTime = time;
src\Unit.js:1375:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1376:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1378:        let foundWater = false;
src\Unit.js:1379:        let foundForest = false;
src\Unit.js:1381:        const sampleOffsets = [
src\Unit.js:1388:            let nx = this.gridX + off.x;
src\Unit.js:1389:            let nz = this.gridZ + off.z;
src\Unit.js:1392:            if (nx < 0) nx = logicalW + nx;
src\Unit.js:1393:            if (nx >= logicalW) nx = nx - logicalW;
src\Unit.js:1394:            if (nz < 0) nz = logicalD + nz;
src\Unit.js:1395:            if (nz >= logicalD) nz = nz - logicalD;
src\Unit.js:1397:            nx = (nx % logicalW + logicalW) % logicalW;
src\Unit.js:1398:            nz = (nz % logicalD + logicalD) % logicalD;
src\Unit.js:1400:            const h = this.terrain.getTileHeight(nx, nz);
src\Unit.js:1402:            if (h <= 0) foundWater = true;
src\Unit.js:1403:            else if (h > 4 && h <= 8) foundForest = true;
src\Unit.js:1412:                    window.game.resources.fish = (window.game.resources.fish || 0) + 1;
src\Unit.js:1416:                const amount = (this.role === 'hunter') ? 3.0 : 1.0;
src\Unit.js:1417:                window.game.resources.meat += amount;
src\Unit.js:1423:        if (!goblins || goblins.length === 0) return;
src\Unit.js:1425:        let nearest = null;
src\Unit.js:1426:        let minScore = Infinity;
src\Unit.js:1428:        const maxDist = (this.role === 'knight' || this.role === 'wizard') ? 50 : 15;
src\Unit.js:1435:            const myCell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1436:            const targetCell = this.terrain.grid[goblin.gridX][goblin.gridZ];
src\Unit.js:1439:                const myRegion = myCell.regionId;
src\Unit.js:1440:                const targetRegion = targetCell.regionId;
src\Unit.js:1444:                    if (targetRegion !== myRegion) continue;
src\Unit.js:1452:            const dx = this.gridX - goblin.gridX;
src\Unit.js:1453:            const dz = this.gridZ - goblin.gridZ;
src\Unit.js:1454:            const dist = Math.sqrt(dx * dx + dz * dz);
src\Unit.js:1458:            const targetH = this.terrain.getTileHeight(goblin.gridX, goblin.gridZ);
src\Unit.js:1459:            let score = dist;
src\Unit.js:1462:                score += 20.0;
src\Unit.js:1466:                minScore = score;
src\Unit.js:1467:                nearest = goblin;
src\Unit.js:1470:        this.targetGoblin = nearest;
src\Unit.js:1474:        let dx = Math.abs(this.gridX - tx);
src\Unit.js:1475:        let dz = Math.abs(this.gridZ - tz);
src\Unit.js:1477:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1478:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1480:        if (dx > logicalW / 2) dx = logicalW - dx;
src\Unit.js:1481:        if (dz > logicalD / 2) dz = logicalD - dz;
src\Unit.js:1490:        const currentRegion = this.terrain.getRegion(this.gridX, this.gridZ);
src\Unit.js:1493:        const radius = (this.role === 'knight') ? 30 : 15;
src\Unit.js:1496:        const target = this.terrain.getRandomPointInRegion(currentRegion, this.gridX, this.gridZ, radius);
src\Unit.js:1520:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1521:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1523:        let found = false;
src\Unit.js:1524:        let attempts = 0;
src\Unit.js:1526:            const rx = Math.floor(Math.random() * 7) - 3;
src\Unit.js:1527:            const rz = Math.floor(Math.random() * 7) - 3;
src\Unit.js:1528:            if (rx === 0 && rz === 0) continue;
src\Unit.js:1530:            let tx = this.gridX + rx;
src\Unit.js:1531:            let tz = this.gridZ + rz;
src\Unit.js:1533:            if (tx < 0) tx = logicalW - 1;
src\Unit.js:1534:            if (tx >= logicalW) tx = 0;
src\Unit.js:1535:            if (tz < 0) tz = logicalD - 1;
src\Unit.js:1536:            if (tz >= logicalD) tz = 0;
src\Unit.js:1538:            const h = this.terrain.getTileHeight(tx, tz);
src\Unit.js:1539:            const cell = this.terrain.grid[tx][tz];
src\Unit.js:1543:                const oldX = this.gridX;
src\Unit.js:1544:                const oldZ = this.gridZ;
src\Unit.js:1545:                this.gridX = tx;
src\Unit.js:1546:                this.gridZ = tz;
src\Unit.js:1550:                found = true;
src\Unit.js:1557:        this.action = 'Migrating';
src\Unit.js:1560:            this.state = new UnitWanderState(this); // Direct set to avoid 'enter' overriding action if not careful
src\Unit.js:1562:        this.migrationTimer = 0;
src\Unit.js:1567:        const logicalW = (this.terrain && this.terrain.logicalWidth) || 80;
src\Unit.js:1568:        const logicalD = (this.terrain && this.terrain.logicalDepth) || 80;
src\Unit.js:1569:        let found = false;
src\Unit.js:1570:        let attempts = 0;
src\Unit.js:1572:            const r = 20 + Math.random() * 20;
src\Unit.js:1573:            const ang = Math.random() * Math.PI * 2;
src\Unit.js:1574:            let tx = this.gridX + Math.cos(ang) * r;
src\Unit.js:1575:            let tz = this.gridZ + Math.sin(ang) * r;
src\Unit.js:1578:            if (tx < 0) tx = (tx % logicalW + logicalW) % logicalW;
src\Unit.js:1579:            else if (tx >= logicalW) tx = tx % logicalW;
src\Unit.js:1581:            if (tz < 0) tz = (tz % logicalD + logicalD) % logicalD;
src\Unit.js:1582:            else if (tz >= logicalD) tz = tz % logicalD;
src\Unit.js:1585:                this.migrationTarget = { x: tx, z: tz };
src\Unit.js:1587:                found = true;
src\Unit.js:1598:            const stateName = this.state.constructor.name;
src\Unit.js:1601:            if (stateName === "UnitWanderState") {
src\Unit.js:1602:                return (this.role === 'knight' || this.role === 'wizard') ? "Patrol" : "Wander";
src\Unit.js:1604:            if (stateName === "CombatState") {
src\Unit.js:1610:            if (stateName === "JobState") return 'Working';
src\Unit.js:1611:            if (stateName === "SleepState") return 'Sleeping';
src\Unit.js:1620:        if (this.role === 'knight' || this.role === 'wizard') return 'Patrol';
src\Unit.js:1625:        this.simTime = time;
src\Unit.js:1633:        const ageRate = (this.role === 'knight' || this.role === 'wizard') ? 0.02 : 0.2;
src\Unit.js:1634:        this.age += deltaTime * ageRate;
src\Unit.js:1635:        if (this.age >= this.lifespan && !this.isDead) { // Redundant !isDead check but safe
src\Unit.js:1675:        if (this.role !== 'worker') return false;
src\Unit.js:1683:        const logicalW = this.terrain.logicalWidth || 80;
src\Unit.js:1684:        const logicalD = this.terrain.logicalDepth || 80;
src\Unit.js:1686:        const x = this.gridX;
src\Unit.js:1687:        const z = this.gridZ;
src\Unit.js:1688:        const cell = this.terrain.grid[x][z];
src\Unit.js:1694:        const buildings = (this.terrain && this.terrain.buildings) ? this.terrain.buildings : [];
src\Unit.js:1695:        const houseCount = buildings.filter(b => b.type === 'house').length;
src\Unit.js:1696:        const farmCount = buildings.filter(b => b.type === 'farm').length;
src\Unit.js:1697:        const mansionCount = buildings.filter(b => b.type === 'mansion').length;
src\Unit.js:1698:        const totalPop = window.game ? window.game.totalPopulation : 0;
src\Unit.js:1701:        const towers = buildings.filter(b => b.type === 'tower');
src\Unit.js:1702:        const towerTarget = Math.floor(totalPop / 3000);
src\Unit.js:1713:        const barracksCount = buildings.filter(b => b.type === 'barracks').length;
src\Unit.js:1715:        const barracksTarget = Math.floor(totalPop / 1000);
src\Unit.js:1727:        const res = (window.game && window.game.resources) ? window.game.resources : { grain: 100 };
src\Unit.js:1728:        const food = res.grain || 0;
src\Unit.js:1729:        const lowFood = food < totalPop * 2;
src\Unit.js:1730:        const lowFarms = farmCount < (houseCount / 2) + 1;
src\Unit.js:1756:        const cell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1757:        const currentM = cell.moisture || 0.5;
src\Unit.js:1758:        const targetM = 0.5;
src\Unit.js:1760:        let diff = targetM - currentM;
src\Unit.js:1761:        let change = diff * 0.4;
src\Unit.js:1764:            change = (diff > 0) ? 0.1 : -0.1;
src\Unit.js:1767:        if (Math.abs(change) > Math.abs(diff)) change = diff;
src\Unit.js:1777:                this.targetRequest = null;
src\Unit.js:1785:        let cell = null;
src\Unit.js:1787:            cell = this.terrain.grid[this.gridX][this.gridZ];
src\Unit.js:1798:            const m = cell.moisture || 0.5;
src\Unit.js:1800:            const diff = Math.abs(m - 0.5);
src\Unit.js:1801:            let successChance = 1.0 - (diff * 2.5);
src\Unit.js:1802:            if (successChance < 0) successChance = 0;
src\Unit.js:1819:            Unit.assets.geometries.crossV = new THREE.BoxGeometry(0.2, 1.0, 0.2);
src\Unit.js:1820:            Unit.assets.geometries.crossH = new THREE.BoxGeometry(0.8, 0.2, 0.2);
src\Unit.js:1826:        const group = new THREE.Group();
src\Unit.js:1827:        const GEO = Unit.getCrossAssets();
src\Unit.js:1829:        const material = new THREE.MeshLambertMaterial({
src\Unit.js:1835:        const vMesh = new THREE.Mesh(GEO.crossV, material);
src\Unit.js:1836:        vMesh.position.y = 0.5;
src\Unit.js:1839:        const hMesh = new THREE.Mesh(GEO.crossH, material);
src\Unit.js:1840:        hMesh.position.y = 0.7;
src\Unit.js:1843:        const pos = this.getPositionForGrid(this.gridX, this.gridZ);
src\Unit.js:1847:        this.crossMesh = group;
src\Unit.js:1848:        this.deathTimer = 0;
src\Unit.js:1854:        if (isNaN(this.deathTimer)) this.deathTimer = 0;
src\Unit.js:1856:        const safeDt = (deltaTime > 0) ? deltaTime : 0.016;
src\Unit.js:1857:        this.deathTimer += safeDt;
src\Unit.js:1859:        const duration = 3.0;
src\Unit.js:1861:        if (this.deathTimer >= duration) {
src\Unit.js:1863:            this.crossMesh.children.forEach(child => {
src\Unit.js:1866:            this.crossMesh = null;
src\Unit.js:1868:            this.isFinished = true;
src\Unit.js:1870:            this.crossMesh.position.y += deltaTime * 1.0;
src\Unit.js:1871:            const progress = this.deathTimer / duration;
src\Unit.js:1872:            this.crossMesh.children.forEach(child => {
src\Unit.js:1873:                child.material.opacity = 1.0 - progress;
src\Unit.js:1879:        const canvas = document.createElement('canvas');
src\Unit.js:1880:        canvas.width = 64;
src\Unit.js:1881:        canvas.height = 64;
src\Unit.js:1882:        const ctx = canvas.getContext('2d');
src\Unit.js:1884:        ctx.fillStyle = '#8B4513';
src\Unit.js:1887:        ctx.strokeStyle = '#5D2906';
src\Unit.js:1888:        ctx.lineWidth = 2;
src\Unit.js:1889:        for (let i = 0; i < 8; i++) {
src\Unit.js:1903:        const canvas = document.createElement('canvas');
src\Unit.js:1904:        canvas.width = 64;
src\Unit.js:1905:        canvas.height = 64;
src\Unit.js:1906:        const ctx = canvas.getContext('2d');
src\Unit.js:1908:        ctx.fillStyle = '#A52A2A';
src\Unit.js:1911:        ctx.fillStyle = '#800000';
src\Unit.js:1912:        for (let y = 0; y < 64; y += 8) {
src\Unit.js:1913:            for (let x = 0; x < 64; x += 8) {
src\Unit.js:1914:                if ((x + y) % 16 === 0) ctx.fillRect(x, y, 7, 7);
src\Unit.js:1923:        let hbx = undefined, hbz = undefined;
src\Unit.js:1925:            hbx = this.homeBase.userData.gridX;
src\Unit.js:1926:            hbz = this.homeBase.userData.gridZ;
src\Unit.js:1968:            this.mesh = null;
src\Unit.js:1973:            this.crossMesh.traverse(c => {
src\Unit.js:1976:            this.crossMesh = null;
src\Unit.js:1988:            tx = this.targetGoblin.gridX;
src\Unit.js:1989:            tz = this.targetGoblin.gridZ;
src\Unit.js:1991:            tx = this.targetBuilding.gridX;
src\Unit.js:1992:            tz = this.targetBuilding.gridZ;
src\Unit.js:1994:            tx = this.targetRaidPoint.x;
src\Unit.js:1995:            tz = this.targetRaidPoint.z;
src\Unit.js:1997:            tx = this.migrationTarget.x;
src\Unit.js:1998:            tz = this.migrationTarget.z;
src\Unit.js:2007:        this.lastPathAttempt = time;
src\Unit.js:2009:        const path = this.terrain.findPath(this.gridX, this.gridZ, tx, tz);
src\Unit.js:2013:            this.path = path;
src\Unit.js:2014:            this.stuckCount = 0; // Reset stuck since we found a solution
src\Unit.js:2019:            if (this.id === 0 || Math.random() < 0.05) console.log(`[Unit ${this.id}] Pathfinding Failed (UNREACHABLE). Blocked by terrain/water? Aborting & Blacklisting.`);
src\Unit.js:2021:            const now = (this.game) ? this.game.simTotalTimeSec : 0;
src\Unit.js:2027:                const id = this.targetBuilding.userData ? (this.targetBuilding.userData.id || this.targetBuilding.id) : this.targetBuilding.id;
src\Unit.js:2035:            this.targetUnit = null;
src\Unit.js:2036:            this.targetGoblin = null; // Ensure this is cleared too
src\Unit.js:2037:            this.targetBuilding = null;
src\Unit.js:2038:            this.targetRaidPoint = null;
src\Unit.js:2039:            this.migrationTarget = null;
src\Unit.js:2040:            this.targetRequest = null; // Drop job if unreachable
src\Unit.js:2041:            this.path = null;
src\Unit.js:2046:        const unit = new Unit(scene, terrain, data.gridX, data.gridZ, data.role || data.isSpecial, data.isSpecial);
src\Unit.js:2047:        unit.id = (data.id !== undefined) ? Number(data.id) : unit.id; // Restore ID as Number
src\Unit.js:2048:        unit.age = data.age || 20;
src\Unit.js:2052:        // Assuming default constructor sets WanderState which makes isMoving=false
src\Unit.js:2055:            unit.isMoving = true;
src\Unit.js:2059:            unit.moveDuration = data.moveDuration;
src\Unit.js:2064:        if (typeof data.lifespan === 'number' && data.lifespan > 0) {
src\Unit.js:2065:            unit.lifespan = data.lifespan;
src\Unit.js:2068:        if (data.lifespan) unit.lifespan = data.lifespan;
src\Unit.js:2070:        unit.isDead = data.isDead || false;
src\Unit.js:2071:        unit.isDead = data.isDead || false;
src\Unit.js:2072:        unit.isFinished = data.isFinished || false;
src\Unit.js:2075:        if (data.hp !== undefined) unit.hp = data.hp;
src\Unit.js:2076:        if (data.maxHp !== undefined) unit.maxHp = data.maxHp;
src\Unit.js:2077:        if (data.damage !== undefined) unit.damage = data.damage;
src\Unit.js:2078:        if (data.xp !== undefined) unit.xp = data.xp;
src\Unit.js:2079:        if (data.level !== undefined) unit.level = data.level;
src\Unit.js:2080:        if (data.level !== undefined) unit.level = data.level;
src\Unit.js:2081:        if (data.name !== undefined) unit.name = data.name;
src\Unit.js:2084:        if (data.homeBaseGridX !== undefined && data.homeBaseGridZ !== undefined) {
src\Unit.js:2085:            unit.savedHomeBaseX = data.homeBaseGridX;
src\Unit.js:2086:            unit.savedHomeBaseZ = data.homeBaseGridZ;
src\Unit.js:2090:        if (data.squadId !== undefined) {
src\Unit.js:2091:            unit.squadId = data.squadId;
src\Unit.js:2093:            unit.squadId = null; // Default for legacy saves
src\Unit.js:2098:            unit.savedTargetRequestId = data.targetRequestId;
src\Unit.js:2107:            if (data.targetGridX !== undefined) unit.targetGridX = data.targetGridX;
src\Unit.js:2108:            if (data.targetGridZ !== undefined) unit.targetGridZ = data.targetGridZ;
src\Unit.js:2111:            unit.isMoving = false;
src\Unit.js:2112:            unit.action = "Idle"; // or leave as is if saved
src\ai\states\UnitStates.js:10:        this.actor.isMoving = false; // Always stop previous movement initially. 
src\ai\states\UnitStates.js:18:            // Do NOT restore Job-related actions (e.g. 'Approaching Job', 'Working') in WanderState
src\ai\states\UnitStates.js:19:            // Only restore 'Migrating' or specific movement actions
src\ai\states\UnitStates.js:20:            if (this.resumeContext.action === 'Migrating') {
src\ai\states\UnitStates.js:21:                this.actor.action = 'Migrating';
src\ai\states\UnitStates.js:23:                    this.actor.migrationTarget = this.resumeContext.migrationTarget;
src\ai\states\UnitStates.js:26:                this.actor.action = 'Idle';
src\ai\states\UnitStates.js:31:                this.actor.targetGridX = this.resumeContext.target.x;
src\ai\states\UnitStates.js:32:                this.actor.targetGridZ = this.resumeContext.target.z;
src\ai\states\UnitStates.js:34:                this.actor.lastPathTime = -100;
src\ai\states\UnitStates.js:43:            if (this.actor.action !== 'Migrating') {
src\ai\states\UnitStates.js:44:                this.actor.action = 'Idle';
src\ai\states\UnitStates.js:69:        const isNight = isNightParam || this.actor.isNight || (window.game && window.game.isNight);
src\ai\states\UnitStates.js:73:                const manReq = window.game.findBestRequest(this.actor, false); // No snatch
src\ai\states\UnitStates.js:76:                        this.actor.targetRequest = manReq;
src\ai\states\UnitStates.js:87:        if (this.actor.role !== 'worker' && this.actor.findRaidTarget && this.actor.findRaidTarget()) {
src\ai\states\UnitStates.js:88:            if (this.actor.action !== 'Migrating' && this.actor.action !== 'Reinforcing') {
src\ai\states\UnitStates.js:96:            const req = window.game.findBestRequest(this.actor, true); // true = allow snatching nearby assigned jobs
src\ai\states\UnitStates.js:99:                    if (this.actor.id === 0) console.log(`[UnitWander] Found Job! ${req.type}.`);
src\ai\states\UnitStates.js:100:                    this.actor.targetRequest = req;
src\ai\states\UnitStates.js:108:        if (this.actor.role === 'worker' && !isNight && !this.actor.targetGoblin && !this.actor.targetBuilding) {
src\ai\states\UnitStates.js:111:                // Just wander/idle for a bit to prevent immediate distraction building
src\ai\states\UnitStates.js:116:                const cell = this.actor.terrain.grid[this.actor.gridX][this.actor.gridZ];
src\ai\states\UnitStates.js:119:                        this.actor.buildTimer = (this.actor.buildTimer || 0) + deltaTime;
src\ai\states\UnitStates.js:120:                        if (this.actor.buildTimer >= 1.0) {
src\ai\states\UnitStates.js:121:                            const success = this.actor.tryBuildStructure(time);
src\ai\states\UnitStates.js:123:                                this.actor.stagnationTimer = 0;
src\ai\states\UnitStates.js:124:                                this.actor.buildTimer = 0;
src\ai\states\UnitStates.js:126:                                this.actor.stagnationTimer = (this.actor.stagnationTimer || 0) + deltaTime;
src\ai\states\UnitStates.js:130:                        this.actor.stagnationTimer = (this.actor.stagnationTimer || 0) + deltaTime;
src\ai\states\UnitStates.js:140:        if (this.actor.role !== 'worker' && !this.actor.targetRequest && !this.actor.targetGoblin && !this.actor.isMoving) {
src\ai\states\UnitStates.js:147:        if (this.actor.action === 'Migrating' && this.actor.migrationTarget) {
src\ai\states\UnitStates.js:148:            this.actor.migrationTimer = (this.actor.migrationTimer || 0) + deltaTime;
src\ai\states\UnitStates.js:154:            const isAttack = this.actor.checkSelfDefense(goblins) && (this.actor.targetGoblin || this.actor.targetBuilding);
src\ai\states\UnitStates.js:156:            const isBusyWorker = (this.actor.role === 'worker' && this.actor.targetRequest);
src\ai\states\UnitStates.js:159:                this.actor.action = 'Fighting';
src\ai\states\UnitStates.js:161:                this.actor.migrationTarget = null;
src\ai\states\UnitStates.js:167:                const dist = this.actor.getDistance(this.actor.migrationTarget.x, this.actor.migrationTarget.z);
src\ai\states\UnitStates.js:169:                    this.actor.action = 'Idle';
src\ai\states\UnitStates.js:170:                    this.actor.migrationTarget = null;
src\ai\states\UnitStates.js:181:        if (!this.actor.isMoving && this.actor.role === 'worker' && Math.random() < 0.05) {
src\ai\states\UnitStates.js:190:        this.targetRequest = actor.targetRequest;
src\ai\states\UnitStates.js:191:        this.resumeState = null;
src\ai\states\UnitStates.js:192:        this.lastMoveAttempt = 0;
src\ai\states\UnitStates.js:193:        this.pathFailures = 0;
src\ai\states\UnitStates.js:194:        this.stuckTimer = 0;
src\ai\states\UnitStates.js:195:        this.checkStuckInterval = 2.0;
src\ai\states\UnitStates.js:196:        this.lastStuckCheck = 0;
src\ai\states\UnitStates.js:197:        this.lastPos = { x: 0, z: 0 };
src\ai\states\UnitStates.js:198:        this.name = "JobState";
src\ai\states\UnitStates.js:203:        // Capture BEFORE we modify actor.action or target properties
src\ai\states\UnitStates.js:204:        this.savedResumeContext = {
src\ai\states\UnitStates.js:205:            action: this.actor.action,
src\ai\states\UnitStates.js:208:            target: (this.actor.isMoving && this.actor.targetGridX !== undefined && this.actor.targetGridZ !== undefined)
src\ai\states\UnitStates.js:214:        this.actor.targetBuilding = null;
src\ai\states\UnitStates.js:215:        this.actor.isSleeping = false;
src\ai\states\UnitStates.js:216:        this.actor.action = 'Approaching Job';
src\ai\states\UnitStates.js:217:        this.actor.isMoving = false;
src\ai\states\UnitStates.js:218:        this.actor.lastPathTime = -100; // Force pathfinding immediately (bypass throttle)
src\ai\states\UnitStates.js:219:        this.targetRequest = this.actor.targetRequest;
src\ai\states\UnitStates.js:223:            const vx = this.actor.getVisualX ? this.actor.getVisualX(0) : this.actor.gridX;
src\ai\states\UnitStates.js:224:            const vz = this.actor.getVisualZ ? this.actor.getVisualZ(0) : this.actor.gridZ;
src\ai\states\UnitStates.js:231:            this.resumeState = prev;
src\ai\states\UnitStates.js:234:        if (this.actor.id === 0) console.log(`[JobState] Entered. Target: ${this.targetRequest ? this.targetRequest.type : 'None'}. ResumeCtx: ${this.savedResumeContext ? this.savedResumeContext.action : 'None'}`);
src\ai\states\UnitStates.js:236:        const time = this.actor.simTime || 0;
src\ai\states\UnitStates.js:237:        this.lastStuckCheck = time;
src\ai\states\UnitStates.js:238:        const vx = this.actor.getVisualX ? this.actor.getVisualX(0) : this.actor.gridX;
src\ai\states\UnitStates.js:239:        const vz = this.actor.getVisualZ ? this.actor.getVisualZ(0) : this.actor.gridZ;
src\ai\states\UnitStates.js:240:        this.lastPos = { x: vx, z: vz };
src\ai\states\UnitStates.js:245:        if (nextState instanceof JobState && nextState.targetRequest && this.targetRequest && nextState.targetRequest.id === this.targetRequest.id) {
src\ai\states\UnitStates.js:249:        if (this.actor.targetRequest && this.targetRequest && this.actor.targetRequest.id === this.targetRequest.id) {
src\ai\states\UnitStates.js:250:            this.actor.targetRequest = null;
src\ai\states\UnitStates.js:257:        const state = new UnitWanderState(this.actor);
src\ai\states\UnitStates.js:258:        state.resumeContext = this.savedResumeContext;
src\ai\states\UnitStates.js:268:        if (this.targetRequest.assignedTo !== this.actor.id) {
src\ai\states\UnitStates.js:273:        if (this.targetRequest.status === 'completed' || this.targetRequest.status === 'expired') {
src\ai\states\UnitStates.js:274:            this.actor.targetRequest = null;
src\ai\states\UnitStates.js:286:        if (this.actor.role === 'worker') {
src\ai\states\UnitStates.js:301:        if (isNightParam && this.actor.role === 'worker') {
src\ai\states\UnitStates.js:305:                this.targetRequest = null;
src\ai\states\UnitStates.js:306:                this.actor.targetRequest = null;
src\ai\states\UnitStates.js:312:        const vx = this.actor.getVisualX ? this.actor.getVisualX(time) : this.actor.gridX;
src\ai\states\UnitStates.js:313:        const vz = this.actor.getVisualZ ? this.actor.getVisualZ(time) : this.actor.gridZ;
src\ai\states\UnitStates.js:314:        const dist = this.actor.getDistance(this.targetRequest.x, this.targetRequest.z, vx, vz);
src\ai\states\UnitStates.js:316:        const approachDist = (this.targetRequest.type === 'raise' || this.targetRequest.type === 'lower') ? 3.0 : 2.0;
src\ai\states\UnitStates.js:318:        if (dist <= approachDist) {
src\ai\states\UnitStates.js:320:                const oldX = this.actor.gridX;
src\ai\states\UnitStates.js:321:                const oldZ = this.actor.gridZ;
src\ai\states\UnitStates.js:322:                this.actor.gridX = Math.round(vx);
src\ai\states\UnitStates.js:323:                this.actor.gridZ = Math.round(vz);
src\ai\states\UnitStates.js:324:                this.actor.isMoving = false;
src\ai\states\UnitStates.js:330:            this.actor.action = "Working";
src\ai\states\UnitStates.js:333:            this.targetRequest = null;
src\ai\states\UnitStates.js:334:            this.actor.targetRequest = null;
src\ai\states\UnitStates.js:337:                const next = window.game.findBestRequest(this.actor);
src\ai\states\UnitStates.js:339:                    this.actor.targetRequest = next;
src\ai\states\UnitStates.js:340:                    this.targetRequest = next;
src\ai\states\UnitStates.js:341:                    this.actor.action = 'Approaching Job';
src\ai\states\UnitStates.js:350:        const isHeadingToTarget = this.actor.isMoving &&
src\ai\states\UnitStates.js:351:            this.actor.targetGridX !== undefined &&
src\ai\states\UnitStates.js:356:            const moved = this.actor.smartMove(this.targetRequest.x, this.targetRequest.z, time);
src\ai\states\UnitStates.js:362:                this.targetRequest = null;
src\ai\states\UnitStates.js:363:                this.actor.targetRequest = null;
src\ai\states\UnitStates.js:364:                this.actor.isUnreachable = false;
src\ai\states\UnitStates.js:369:            this.lastMoveAttempt = time;
src\ai\states\UnitStates.js:373:                const failureInc = (this.targetRequest.isManual) ? 5 : 1;
src\ai\states\UnitStates.js:374:                this.pathFailures = (this.pathFailures || 0) + failureInc;
src\ai\states\UnitStates.js:375:                this.actor.stuckCount = (this.actor.stuckCount || 0) + failureInc;
src\ai\states\UnitStates.js:378:                    this.actor.lastPathTime = 0;
src\ai\states\UnitStates.js:379:                    this.actor.stuckCount = 0;
src\ai\states\UnitStates.js:382:                const isUnreachable = this.actor.isReachable && !this.actor.isReachable(this.targetRequest.x, this.targetRequest.z);
src\ai\states\UnitStates.js:384:                // STICKY JOBS: Reduce threshold for manual jobs (100 = approx 6-10s of blocking)
src\ai\states\UnitStates.js:385:                const failureThreshold = (this.targetRequest && this.targetRequest.isManual) ? 100 : 5;
src\ai\states\UnitStates.js:393:                    // But checking logic: exit uses (this.actor.targetRequest === this.targetRequest)
src\ai\states\UnitStates.js:397:                    this.actor.targetRequest = null;
src\ai\states\UnitStates.js:398:                    this.targetRequest = null;
src\ai\states\UnitStates.js:401:                    this.actor.lastJobAbortTime = time;
src\ai\states\UnitStates.js:409:                if (moved) this.pathFailures = 0;
src\ai\states\UnitStates.js:413:        if (time - this.lastStuckCheck >= this.checkStuckInterval) {
src\ai\states\UnitStates.js:414:            this.lastStuckCheck = time;
src\ai\states\UnitStates.js:422:            const dx = Math.abs(vx - this.lastPos.x);
src\ai\states\UnitStates.js:423:            const dz = Math.abs(vz - this.lastPos.z);
src\ai\states\UnitStates.js:425:                this.stuckTimer += this.checkStuckInterval;
src\ai\states\UnitStates.js:426:                const stuckThreshold = (this.targetRequest && this.targetRequest.isManual) ? 45.0 : 15.0; // Reduced from 300 to 45
src\ai\states\UnitStates.js:431:                    this.actor.targetRequest = null;
src\ai\states\UnitStates.js:432:                    this.targetRequest = null;
src\ai\states\UnitStates.js:438:                this.stuckTimer = 0;
src\ai\states\UnitStates.js:439:                this.lastPos = { x: vx, z: vz };
src\ai\states\UnitStates.js:450:        this.stagnationTimer = 0;
src\ai\states\UnitStates.js:451:        this.name = "CombatState";
src\ai\states\UnitStates.js:455:        this.savedResumeContext = {
src\ai\states\UnitStates.js:456:            action: this.actor.action,
src\ai\states\UnitStates.js:458:            target: (this.actor.isMoving && this.actor.targetGridX !== undefined && this.actor.targetGridZ !== undefined)
src\ai\states\UnitStates.js:465:        this.actor.isSleeping = false;
src\ai\states\UnitStates.js:466:        this.actor.migrationTarget = null;
src\ai\states\UnitStates.js:467:        if (this.actor.role === 'worker' && this.actor.targetRequest && window.game) {
src\ai\states\UnitStates.js:469:            this.actor.targetRequest = null;
src\ai\states\UnitStates.js:471:        this.actor.action = 'Fighting';
src\ai\states\UnitStates.js:472:        this.stagnationTimer = 0;
src\ai\states\UnitStates.js:477:        const state = new UnitWanderState(this.actor);
src\ai\states\UnitStates.js:478:        state.resumeContext = this.savedResumeContext;
src\ai\states\UnitStates.js:494:        if (this.actor.role === 'worker' && window.game) {
src\ai\states\UnitStates.js:495:            const manReq = window.game.findBestRequest(this.actor, false); // Only pending
src\ai\states\UnitStates.js:498:                    this.actor.targetRequest = manReq;
src\ai\states\UnitStates.js:506:            const terrain = this.actor.terrain || window.game?.terrain;
src\ai\states\UnitStates.js:508:                this.actor.targetBuilding = null;
src\ai\states\UnitStates.js:514:        this.stagnationTimer += deltaTime;
src\ai\states\UnitStates.js:516:            this.actor.targetGoblin = null;
src\ai\states\UnitStates.js:517:            this.actor.targetBuilding = null;
src\ai\states\UnitStates.js:523:        let target = this.actor.targetGoblin || this.actor.targetBuilding;
src\ai\states\UnitStates.js:534:        let dist = 999;
src\ai\states\UnitStates.js:536:            dist = this.actor.getDistance(this.actor.targetGoblin.gridX, this.actor.targetGoblin.gridZ);
src\ai\states\UnitStates.js:538:            dist = this.actor.getDistance(this.actor.targetBuilding.gridX, this.actor.targetBuilding.gridZ);
src\ai\states\UnitStates.js:540:            if (this.actor.targetBuilding.userData && this.actor.targetBuilding.userData.type === 'cave') dist -= 1.0;
src\ai\states\UnitStates.js:544:        if (dist < 3.0) this.stagnationTimer = 0;
src\ai\states\UnitStates.js:547:        let range = 1.5; // Melee
src\ai\states\UnitStates.js:548:        if (this.actor.role === 'wizard') range = 8.0;
src\ai\states\UnitStates.js:553:            let tx = target.gridX;
src\ai\states\UnitStates.js:554:            let tz = target.gridZ;
src\ai\states\UnitStates.js:559:            this.actor.action = "Chasing";
src\ai\states\UnitStates.js:564:        this.actor.action = "Fighting";
src\ai\states\UnitStates.js:565:        this.actor.isMoving = false; // Stop to hit
src\ai\states\UnitStates.js:568:        const dx = target.gridX - this.actor.gridX;
src\ai\states\UnitStates.js:569:        const dz = target.gridZ - this.actor.gridZ;
src\ai\states\UnitStates.js:570:        this.actor.rotationY = Math.atan2(dx, dz);
src\ai\states\UnitStates.js:574:            this.actor.attackCooldown -= deltaTime;
src\ai\states\UnitStates.js:580:        let damage = 10;
src\ai\states\UnitStates.js:581:        let rate = 1.0;
src\ai\states\UnitStates.js:583:        if (this.actor.role === 'knight') { damage = 20; rate = 0.8; }
src\ai\states\UnitStates.js:584:        else if (this.actor.role === 'wizard') { damage = 35; rate = 2.0; }
src\ai\states\UnitStates.js:585:        else if (this.actor.role === 'worker') { damage = 5; rate = 1.0; }
src\ai\states\UnitStates.js:593:                this.actor.targetGoblin = null;
src\ai\states\UnitStates.js:602:                if (target.userData && target.userData.hp !== undefined) {
src\ai\states\UnitStates.js:603:                    target.userData.hp -= damage;
src\ai\states\UnitStates.js:604:                    if (target.userData.hp <= 0 && window.game && window.game.terrain) {
src\ai\states\UnitStates.js:607:                        this.actor.targetBuilding = null;
src\ai\states\UnitStates.js:613:        this.actor.attackCooldown = rate;
src\ai\states\UnitStates.js:624:        if (this.actor.id === 0) console.log(`[SleepState] Entering Sleep logic.`);
src\ai\states\UnitStates.js:625:        this.actor.action = "Sleeping";
src\ai\states\UnitStates.js:626:        this.actor.isSleeping = false; // Start by moving to shelter
src\ai\states\UnitStates.js:627:        this.update(this.actor.simTime || 0, 0, true); // Force isNightParam=true since we are entering SleepState
src\ai\states\UnitStates.js:630:        this.actor.isSleeping = false;
src\ai\states\UnitStates.js:633:        const isNight = isNightParam || (window.game && window.game.isNight);
src\ai\states\UnitStates.js:637:            this.actor.isSleeping = false;
src\ai\states\UnitStates.js:638:            this.actor.targetRequest.status = 'assigned'; // Reinforce
src\ai\states\UnitStates.js:644:            this.actor.isSleeping = false;
src\ai\states\UnitStates.js:650:            this.actor.isSleeping = false;
src\ai\states\UnitStates.js:656:        if (this.actor.role === 'worker' && window.game) {
src\ai\states\UnitStates.js:657:            const manReq = window.game.findBestRequest(this.actor, false);
src\ai\states\UnitStates.js:660:                    this.actor.isSleeping = false;
src\ai\states\UnitStates.js:661:                    this.actor.targetRequest = manReq;
src\ai\states\UnitStates.js:670:        const shelter = this.actor.findNearestShelter ? this.actor.findNearestShelter() : null;
src\ai\states\UnitStates.js:672:            const dist = this.actor.getDistance(shelter.gridX, shelter.gridZ);
src\ai\states\UnitStates.js:674:                this.actor.isSleeping = true;
src\ai\states\UnitStates.js:675:                this.actor.isMoving = false;
src\ai\states\UnitStates.js:676:                this.actor.action = "Sleeping";
src\ai\states\UnitStates.js:678:                this.actor.action = "Going Home";
src\ai\states\UnitStates.js:682:            this.actor.isSleeping = true;
src\ai\states\UnitStates.js:683:            this.actor.isMoving = false;
