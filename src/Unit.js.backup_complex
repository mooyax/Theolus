import * as THREE from 'three';

import { Actor } from './Actor.js';

export class Unit extends Actor {
    static assets = {
        geometries: {},
        materials: {},
        textures: {}
    };
    static nextId = 0;

    static initAssets() {
        if (Unit.assets.initialized) return;

        // Geometries
        // Geometries (Reverted to Cute/Chibi proportions)
        const bodyGeo = new THREE.BoxGeometry(0.3, 0.35, 0.2);
        bodyGeo.translate(0, 0.3, 0); // Center height ~0.3
        Unit.assets.geometries.body = bodyGeo;

        const headGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        headGeo.translate(0, 0.6, 0);
        Unit.assets.geometries.head = headGeo;

        // Face Plane (Separate mesh to allow independent tinting of Hair/Helmet vs Face)
        const faceGeo = new THREE.PlaneGeometry(0.2, 0.2);
        faceGeo.translate(0, 0.6, 0.126); // Slightly in front of Head Box (Z=0.125)
        Unit.assets.geometries.facePlane = faceGeo;

        const limbGeo = new THREE.BoxGeometry(0.1, 0.25, 0.1);
        limbGeo.translate(0, -0.1, 0); // Pivot at top
        Unit.assets.geometries.limb = limbGeo;

        // Sword (Blade + Hilt joined? No, simple box for chibi)
        // Blade: 0.05 x 0.4 x 0.05
        const swordGeo = new THREE.BoxGeometry(0.05, 0.5, 0.05);
        swordGeo.translate(0, 0.25, 0); // Handle at bottom
        Unit.assets.geometries.sword = swordGeo;

        // Staff (Long pole)
        const staffGeo = new THREE.BoxGeometry(0.05, 0.8, 0.05);
        staffGeo.translate(0, 0, 0); // Center held
        Unit.assets.geometries.staff = staffGeo;

        // Wizard Hat (Cone + Brim)
        // Brim: Cylinder thin
        const brimGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.02, 16);
        brimGeo.translate(0, 0, 0);
        // Cone
        const coneGeo = new THREE.ConeGeometry(0.15, 0.4, 16);
        coneGeo.translate(0, 0.2, 0);

        // Merge for simple instancing? Or kept separate?
        // Let's merge for single draw call per hat
        // Requires BufferGeometryUtils which might not be imported here?
        // Unit.js imports THREE.
        // Let's just use Cone for now for simplicity or complex if imported.
        // Actually Unit.js doesn't import Utils.
        // Let's use two meshes in Renderer or just the Cone for now?
        // User asked for "Gandalf like". Needs brim.
        // We will define them separate and render separate or use a Group logic?
        // InstancedMesh supports one Geometry.
        // We will just define `wizardHat` as the Cone part and `wizardHatBrim`?
        // Or we can construct a merged geometry manually if simple?
        // Let's stick to simple: Just a tall Cone for now, maybe add brim later if needed or modify `UnitRenderer` to handle multi-part hat.
        // Wait, I can't merge easily without util.
        // Let's define `hat` as just the Cone for now, but wide base.
        const hatGeo = new THREE.ConeGeometry(0.2, 0.5, 16);
        hatGeo.translate(0, 0.25, 0);
        Unit.assets.geometries.wizardHat = hatGeo;

        // Brim (Separate for Renderer to handle? Or renderer renders 2 parts?)
        const hatBrimGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.02, 16);
        Unit.assets.geometries.wizardHatBrim = hatBrimGeo;

        // Materials
        // Standard
        Unit.assets.materials.skin = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.8 });
        Unit.assets.materials.clothes = new THREE.MeshStandardMaterial({ color: 0x885533, roughness: 1.0 });
        Unit.assets.materials.tool = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5 });
        Unit.assets.materials.hat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 1.0 });

        // Knight Materials
        Unit.assets.materials.armor = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
        Unit.assets.materials.helmet = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.1 });

        // Wizard Materials
        Unit.assets.materials.robe = new THREE.MeshStandardMaterial({ color: 0x444499, roughness: 1.0 });
        Unit.assets.materials.robe = new THREE.MeshStandardMaterial({ color: 0x444499, roughness: 1.0 });
        Unit.assets.materials.wizardHat = new THREE.MeshStandardMaterial({ color: 0x333388, roughness: 1.0 });

        // New Item Materials
        Unit.assets.materials.metal = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, metalness: 0.9, roughness: 0.2 });
        Unit.assets.materials.wood = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
        Unit.assets.materials.darkMagic = new THREE.MeshStandardMaterial({ color: 0x330033, roughness: 1.0 });

        // Faces & Textures
        Unit.assets.textures.face = Unit.createFaceTexture();
        Unit.assets.materials.face = new THREE.MeshStandardMaterial({ map: Unit.assets.textures.face, transparent: true });

        Unit.assets.textures.hair = Unit.createHairTexture();
        // Use Lambert to match body lighting and prevent 'Standard' material darkening
        Unit.assets.materials.hair = new THREE.MeshLambertMaterial({ map: Unit.assets.textures.hair, transparent: true });

        Unit.assets.materials.heads = null; // Deprecated (Split meshes)

        Unit.assets.initialized = true;
    }

    static createFaceTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFCCAA'; ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = '#4A3000'; ctx.fillRect(0, 0, 64, 15);
        ctx.fillStyle = '#000000'; ctx.fillRect(15, 25, 8, 8); ctx.fillRect(41, 25, 8, 8);
        ctx.fillStyle = '#A0522D'; ctx.fillRect(20, 45, 24, 4);
        return new THREE.CanvasTexture(canvas);
    }

    static createHairTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        // Grayscale Noise for Tinting - Use WHITE base to preserve true tint color
        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, 64, 64); // White Base
        ctx.fillStyle = '#DDDDDD'; // Very Light Grey Noise
        for (let i = 0; i < 40; i++) {
            ctx.fillRect(Math.random() * 60, Math.random() * 60, 4, 4);
        }
        return new THREE.CanvasTexture(canvas);
    }

    constructor(scene, terrain, x, z, role, isSpecial = false, squadId = null) {
        super(scene, terrain, x, z, 'unit');

        // Remove manual ID (Use Entity's if standardized, or keep manual overlap?)
        // UnitMain initialized ID manually. Entity does too.
        // Let's use Base ID. BUT Unit has static nextId=0. 
        // If we switch to Base ID, IDs might change.
        // Let's Keep Unit's ID logic for now to avoid tests breaking?
        // Actually best to override ID with Unit's counter if we want strict compatibility,
        // OR just delete Unit's counter and use Entity's.
        // Entity.nextId starts at 0. Unit.nextId starts at 0.
        // If we use Entity.nextId, Goblins and Units share the pool.
        // Tests expect Unit ID 0. If Goblin Created first, Unit might be ID 1.
        // Let's force override ID in Unit to use Unit.nextId for compatibility.
        this.id = Unit.nextId++;

        console.log(`[UnitCore.js] Unit Created ID:${this.id} Role:${role} Pos:${x},${z} Special:${isSpecial}`);
        this.gridX = (x !== undefined) ? x : 20;
        this.gridZ = (z !== undefined) ? z : 20;

        // Legacy compatibility check (if role arg is boolean)
        // Check if role is boolean (old style: new Unit(..., isSpecial))
        let specialFlag = isSpecial;
        if (typeof role === 'boolean') {
            specialFlag = role;
            role = 'worker';
        }

        this.role = role || 'worker';
        this.role = role || 'worker';
        this.isSpecial = specialFlag;
        this.squadId = squadId; // Squad ID for coordinated attacks

        this.lastGridX = this.gridX;
        this.lastGridZ = this.gridZ;
        this.lastGridX = this.gridX;
        this.lastGridZ = this.gridZ;
        this.stagnationTimer = 0;
        this.buildStagnationCount = 0;
        this.lastTime = 0; // Fix: Undefined caused logic failure
        this.lastGatherTime = -Math.random() * 30; // Stagger gathering

        // Position & Rotation Data (No Mesh)
        this.position = new THREE.Vector3();
        this.rotationY = 0;
        this.limbs = {
            leftArm: { x: 0 },
            rightArm: { x: 0 },
            leftLeg: { x: 0 },
            rightLeg: { x: 0 }
        };

        // Lifespan
        // Reverted to original lifespan (50-80 sim seconds)
        // With staggered update (half speed), this is ~2-3 mins real time.
        // Special Unit = 6-9 mins.
        // User Request: Lifespan 80-100 years.
        // Aging Rate remains same (Worker=1yr/s, Soldier=1yr/10s).
        const baseLifespan = 80 + Math.random() * 20;
        this.lifespan = baseLifespan;

        this.age = 20; // Starts at 20 years old
        this.isDead = false;
        this.isFinished = false;
        this.crossMesh = null;

        // Combat Stats (Default - Worker)
        this.hp = 35 + Math.floor(Math.random() * 15); // Nerfed (Avg 42)
        this.maxHp = this.hp;
        this.attackCooldown = 0;
        this.attackRate = 1.0;
        this.damage = 4; // Nerfed (Goblin has 30HP -> 8 hits)
        this.targetGoblin = null;

        // Stats Overrides
        if (this.role === 'knight') {
            this.hp *= 15; // Massive HP (40x15 = 600) - Overwhelming
            this.maxHp = this.hp;
            this.damage *= 25; // 100 Dmg (Definitely 1-shot Normal Goblin)
        } else if (this.role === 'wizard') {
            this.hp *= 3; // Buffed (40x3 = 120) - Strong enough to survive
            this.maxHp = this.hp;
            this.damage *= 20; // 80 Dmg (1-shot Normal, 2-shot Hob)
            this.attackRate = 2.0; // Slower attack? Or faster? "Multi-target"
            // Range handled in logic
        }

        this.updatePosition();

        this.moveTimer = 0;
        this.moveDuration = 1000;
        this.moveStartTime = 0;
        this.startGridX = 0;
        this.startGridZ = 0;
        this.targetGridX = 0;
        this.targetGridZ = 0;

        // Action Timers
        this.lastTime = 0;
        // Reduced interval for more active units (2s - 5s)
        this.moveInterval = 2000 + Math.random() * 3000;
        if (this.role === 'knight' || this.role === 'wizard') {
            this.moveInterval = 0; // Soldiers act immediately on spawn
        }

        this.stagnationTimer = 0;
        this.huntingCooldown = 0;
        this.target = null; // Assuming 'Target' was a typo for 'this.target'

        // Animation state
        this.isMoving = false;
        this.targetX = 0;
        this.targetZ = 0;
        // this.moveStartTime = 0; // Already defined above
        // this.moveDuration = 1000; // Already defined above

        // Register in Spatial Grid
        this.terrain.registerEntity(this, this.gridX, this.gridZ, 'unit');

        this.wanderCount = 0;
        this.migrationTarget = null;

        // Target Ignoring Logic (Replaces global cooldown)
        this.ignoredTargets = new Map(); // id -> timestamp until ignored
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.die();
        }
    }

    die() {
        if (this.isDead) return;
        this.isDead = true;
        this.terrain.unregisterEntity(this);

        // Release any held job
        if (this.role === 'worker' && this.targetRequest && window.game) {
            console.log(`Unit ${this.id} died. Releasing job ${this.targetRequest.id}`);
            window.game.releaseRequest(this, this.targetRequest);
            this.targetRequest = null;
        }

        this.createCross();
        console.log(`Unit died.`);
    }

    attackGoblin(goblin) {
        // console.log(`[Unit Debug] Attack request. CD: ${this.attackCooldown}`);
        if (this.attackCooldown > 0) return;
        if (goblin.isDead) {
            this.targetGoblin = null;
            return;
        }

        console.log(`[Unit Debug] ATTACKING Goblin ${goblin.id}`);
        if (this.role === 'wizard') {
            // Ranged Attack Animation
            this.limbs.leftArm.x = -Math.PI; // Raise staff
            this.limbs.rightArm.x = -Math.PI;

            // Spawn Fireball Visual
            if (window.game && window.game.spawnProjectile) {
                const startPos = this.position.clone().add(new THREE.Vector3(0, 0.9, 0)); // Head/Staff level
                // We don't have goblin precise position stored in logic? 
                // We have gridX/Z. Need visualization position or estimated.
                const h = this.terrain.getTileHeight(goblin.gridX, goblin.gridZ);
                // Convert grid to world for target
                // Assuming standard centering:
                const logicalW = this.terrain.logicalWidth || 80;
                const logicalD = this.terrain.logicalDepth || 80;

                // Note: Goblin position might not be perfectly synced if it's moving, 
                // but grid center is close enough for a fireball target.
                const targetPos = new THREE.Vector3(
                    (goblin.gridX - logicalW / 2),
                    h + 1.0, // Chest height
                    (goblin.gridZ - logicalD / 2)
                );

                window.game.spawnProjectile(startPos, targetPos);
            }

            setTimeout(() => {
                if (!this.isDead) {
                    this.limbs.leftArm.x = 0;
                    this.limbs.rightArm.x = 0;
                }
            }, 500);
        } else {
            // Melee (Soldier/Worker)
            this.limbs.rightArm.x = -Math.PI / 2;
            setTimeout(() => {
                if (!this.isDead) this.limbs.rightArm.x = 0;
            }, 200);
        }

        // DAMAGE LOGIC
        goblin.takeDamage(this.damage);

        // Report Combat to Squad/Global Memory (Every hit matches "In Combat" status)
        if (this.role === 'knight' || this.role === 'wizard') {
            this.reportEnemy(goblin);
        }

        if (goblin.hp <= 0) {
            goblin.isDead = true;
            this.targetGoblin = null;
            // AI Memory: Record this kill location
            if (window.game && (this.role === 'knight' || this.role === 'wizard')) {
                this.searchForHut(goblin.gridX, goblin.gridZ);
            }
        }

        this.attackCooldown = this.attackRate;
    }

    attackBuilding(building) {
        if (this.attackCooldown > 0) return;

        // VISUALS
        if (this.role === 'wizard') {
            this.limbs.leftArm.x = -Math.PI;
            this.limbs.rightArm.x = -Math.PI;
            setTimeout(() => {
                if (!this.isDead) {
                    this.limbs.leftArm.x = 0;
                    this.limbs.rightArm.x = 0;
                }
            }, 500);
        } else {
            this.limbs.rightArm.x = -Math.PI / 2;
            setTimeout(() => {
                if (!this.isDead) this.limbs.rightArm.x = 0;
            }, 200);
        }

        // DAMAGE LOGIC
        if (building.userData.hp === undefined) building.userData.hp = 100; // Legacy Safety
        building.userData.hp -= this.damage;

        // Feedback
        console.log(`Unit ${this.id} attacking ${building.type}. HP: ${building.userData.hp}`);

        if (building.userData.hp <= 0) {
            console.log(`Building ${building.type} Destroyed!`);
            this.terrain.removeBuilding(building);
            this.targetBuilding = null;

            // Search surroundings for next target
            this.searchSurroundings(this.gridX, this.gridZ);
        }

        this.attackCooldown = this.attackRate;
    }

    debugGetAge() {
        return "DEBUG_AGE_" + this.age;
    }

    getBehaviorMode() {
        if (this.isDead) return "Dead";

        // Combat High Priority
        if (this.targetGoblin) return "Combat";
        if (this.targetBuilding) return "Siege";

        // Movement / Job
        if (this.targetRequest) return "Working";

        // Exploration (Moving to a distant point)
        if (this.targetRaidPoint) {
            return `Exploration (${this.targetRaidPoint.x},${this.targetRaidPoint.z})`;
        }

        // Migration (Moving to new home)
        if (this.action === 'Migrating') return "Migrating";

        // Fallback based on Role
        if (this.role === 'worker') return "Wander";
        if (this.role === 'knight' || this.role === 'wizard') return "Patrol";

        return "Idle";
    }

    updateLogic(time, deltaTime, isNight, goblins, fishes, sheeps) {
        if (this.id === 0) console.log(`[Unit.js] ENTERED updateLogic. Dead=${this.isDead}`);
        if (this.isDead) {
            this.updateDeathAnimation(deltaTime);
            this.action = "Dead";
            return;
        }

        if (this.id === 0) {
            const h = this.terrain.getTileHeight(this.gridX, this.gridZ);
            console.log(`[Unit Debug V2] Start Logic. Night=${isNight}, Stag=${this.stagnationTimer.toFixed(1)}, Age=${this.age.toFixed(1)}, H=${h}, Action=${this.action}`);
        }

        // DEBUG HEARTBEAT
        if (this.id === 0) {
            if (this.debugFrame % 60 === 0) {
                console.log(`[Unit Heartbeat] ID:${this.id} Action:${this.action} Moving:${this.isMoving} T:${time.toFixed(1)} dt:${deltaTime.toFixed(4)} Int:${this.moveInterval.toFixed(0)}`);
            }
        }

        // Combat Cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= deltaTime;
        }

        if (this.isMoving) {
            this.updateMovement(time);
        }

        // Cleanup Ignored Targets
        if (this.ignoredTargets.size > 0) {
            for (const [id, expiry] of this.ignoredTargets) {
                if (time > expiry) this.ignoredTargets.delete(id);
            }
        }

        // STUCK MONITOR (Long Term Physics Fail)
        if (this.isMoving && time - this.moveStartTime > 20000) {
            console.warn(`[Unit] Stuck moving for >20s. Forcing Reset. ID:${this.id}`);
            this.isMoving = false;
            this.updatePosition();

            // Release failed job
            if (this.role === 'worker' && this.targetRequest && window.game) {
                console.warn(`Unit ${this.id} stuck. Releasing job ${this.targetRequest.id}`);
                window.game.releaseRequest(this, this.targetRequest);
                this.targetRequest = null;
                this.action = 'Idle';
            }
        }

        // STUCK WORKING CLEANUP
        if (this.action === 'Working' && !this.targetRequest) {
            // console.warn(`[Unit ${this.id}] Stuck in 'Working' without job. Resetting to Idle.`);
            this.action = 'Idle';
            this.isMoving = false;
        }

        // GHOST JOB MONITOR
        // Verify our job still exists and is ours
        if (this.role === 'worker' && this.targetRequest && window.game) {
            if (this.debugFrame % 60 === 0) {
                const req = this.targetRequest;
                // Check if req is in queue (or efficient lookup if possible, but queue is small < 100)
                const isValid = window.game.requestQueue.includes(req);
                const isOurs = (req.assignedTo === this.id); // If status reverted to pending, this is false

                if (!isValid || !isOurs) {
                    console.warn(`[Unit ${this.id}] Detected GHOST Job (Valid:${isValid}, Ours:${isOurs}). Dropping.`);
                    this.targetRequest = null;
                    this.action = 'Idle';
                    this.isMoving = false; // Stop approaching ghost
                }
            }
        }

        // Default action
        // Default action
        if (!this.isMoving && time >= this.lastTime && this.action !== 'Migrating') this.action = "Idle";

        // Aging
        let agingRate = 1.0;
        if (this.role === 'knight' || this.role === 'wizard') {
            agingRate = 0.1;
        }
        // console.log(`[DEBUG Unit ${this.id}] incrementing age by ${deltaTime * agingRate}. Current: ${this.age}`);
        this.age += deltaTime * agingRate;
        if (this.age >= this.lifespan) {
            this.die();
            return;
        }

        // WATER DEATH CHECK
        const h = this.terrain.getTileHeight(this.gridX, this.gridZ);
        if (h <= 0) {
            this.die();
            return;
        }

        // --- MIGRATION LOGIC (Continuous Walking) ---
        if (this.action === 'Migrating' && this.migrationTarget) {
            // 1. Timeout Logic
            this.migrationTimer = (this.migrationTimer || 0) + deltaTime;
            if (this.migrationTimer > 30.0) {
                console.log(`Unit ${this.id} migration timed out. Retrying.`);
                this.migrate(time);
                return;
            }

            // 2. Priority Interrupt (Combat & Buildings) - Throttle to 10% chance per frame or simple timer
            // To avoid heavy `searchSurroundings` every frame.
            if (Math.random() < 0.05) {
                // WORKER JOB CHECK (Fix for Ignoring Jobs while Migrating)
                if (this.role === 'worker' && window.game) {
                    const req = window.game.findBestRequest(this);
                    if (req) {
                        if (window.game.claimRequest(this, req)) {
                            console.log(`Unit ${this.id} interrupted migration for Job ${req.type}`);
                            this.targetRequest = req;
                            this.action = 'Idle';
                            this.migrationTarget = null;
                            this.migrationTimer = 0;
                            return;
                        }
                    }
                }

                this.searchSurroundings(this.gridX, this.gridZ, goblins);
                // If search found something, searchSurroundings sets targetGoblin/targetBuilding
                // IF we are a Worker, we shouldn't interrupt for Buildings unless it's a Hut (which we handle)
                // But searchSurroundings already handles "finding" logic (logging mostly).
                // We need to check if we HAVE a target now.

                // Note: searchSurroundings doesn't inherently set `action` to Chasing automatically? 
                // updateLogic (next frame) would pick it up if we weren't in this `if` block.
                // So we must break out of Migrating if we found something.
                if (this.targetGoblin || (this.targetBuilding && this.role !== 'worker')) {
                    console.log(`Unit ${this.id} interrupted migration for combat.`);
                    this.action = 'Idle';
                    this.migrationTarget = null;
                    this.migrationTimer = 0;
                    return; // Let standard logic handle chasin next frame
                }
            }

            // Continue Moving
            const dist = this.getDistance(this.migrationTarget.x, this.migrationTarget.z);
            if (dist <= 2.0) {
                console.log(`Unit ${this.id} finished migration.`);
                this.action = 'Idle';
                this.migrationTarget = null;
                this.migrationTimer = 0;
            } else {
                if (!this.isMoving && (time - (this.lastMoveAttempt || 0) > 1000)) {
                    this.lastMoveAttempt = time;
                    this.triggerMove(this.migrationTarget.x, this.migrationTarget.z, time);
                }
            }
            return; // Early return for migrating state
        }

        // --- TARGET SCANNING ---
        {
            // Priority: Calculate Best Target (Goblin vs Building)
            let bestTarget = null;
            let bestScore = Infinity; // Lower is better

            // COMMITMENT LOGIC:
            const hasValidGoblin = this.targetGoblin && !this.targetGoblin.isDead;
            const hasValidBuilding = this.targetBuilding && this.targetBuilding.userData.hp > 0;
            let isBusy = (this.action === 'Chasing' || this.action === 'Fighting' || this.action === 'Sieging' || this.action === 'Unstuck');

            // WORKER PACIFISM
            if (this.role === 'worker' && this.targetRequest) isBusy = true;

            this.scanTimer = (this.scanTimer || 0) + 1;

            // Adaptive Scan Rate
            // If we have a target, scan LESS frequently (every ~5s) to avoid jitter/indecision.
            // If we have NO target, scan frequently (every ~0.5s) to find one fast.
            let scanInterval = 30;
            if (hasValidGoblin || hasValidBuilding) {
                scanInterval = 300; // 5 seconds commitment
            }

            const forceScan = (this.scanTimer > scanInterval);

            // Logic: Scan if Idle OR Invalid Target OR Force Scan... UNLESS Worker is Working
            let shouldScan = (!isBusy || (!hasValidGoblin && !hasValidBuilding) || forceScan);
            if (this.role === 'worker' && this.targetRequest) shouldScan = false;

            if (shouldScan) {
                if (forceScan) this.scanTimer = 0;

                // Current Target Data for Hysteresis
                const currentTargetId = this.targetGoblin ? this.targetGoblin.id :
                    (this.targetBuilding ? this.targetBuilding.id : null);

                // 1. Scan Goblins
                if (goblins) {
                    const maxDist = (this.role === 'knight' || this.role === 'wizard') ? 50 : 15;

                    for (const g of goblins) {
                        if (g.isDead) continue;
                        if (this.ignoredTargets.has(g.id)) continue;

                        const d = this.getDistance(g.gridX, g.gridZ);

                        // Strict Region Check (User Request: Stop sticking to cross-sea enemies)
                        // Only allow targeting different regions if ALREADY fighting or VERY close (Melee range)
                        const myRegion = (this.terrain.grid[this.gridX] && this.terrain.grid[this.gridX][this.gridZ]) ? this.terrain.grid[this.gridX][this.gridZ].regionId : 1;
                        const gRegion = (this.terrain.grid[g.gridX] && this.terrain.grid[g.gridX][g.gridZ]) ? this.terrain.grid[g.gridX][g.gridZ].regionId : 1;

                        if (myRegion !== gRegion) {
                            // Exception: If distance is tiny (melee range), allow it (e.g. edge of bridge)
                            if (d > 2.5) continue;
                        }

                        // Relaxed Range for Current Target (Stickiness)
                        let limit = maxDist;
                        if (g.id === currentTargetId) limit = maxDist * 2.0;

                        if (d > limit) continue;

                        const h = this.terrain.getTileHeight(g.gridX, g.gridZ);
                        let score = d - 1000.0; // Base priority for Goblins (High)
                        if (h > 8) score += 20;

                        // Sticky Bonus (Huge hysteresis to prevent switching)
                        // If this is our current target, artificially lower its score (make it better)
                        if (g.id === currentTargetId) score -= 500.0;

                        if (score < bestScore) {
                            bestScore = score;
                            bestTarget = { type: 'goblin', obj: g };
                        }
                    }
                }

                // 2. Scan Buildings
                if (this.terrain.buildings) {
                    const range = (this.role === 'knight' || this.role === 'wizard') ? Infinity : 30;
                    for (const b of this.terrain.buildings) {
                        if (this.role === 'worker' && b.type !== 'goblin_hut') continue;
                        if (b.type === 'goblin_hut' || b.type === 'cave') {
                            if (b.userData && b.userData.hp <= 0) continue;
                            if (this.ignoredTargets.has(b.id)) continue;
                            const d = this.getDistance(b.gridX, b.gridZ);
                            if (d > range) continue;

                            let score = d - 5.0; // Lower priority than goblins (-1000)
                            if (b.id === currentTargetId) score -= 500.0; // Sticky Bonus

                            // Special logic: Don't hug caves if active goblins are nearby?
                            if (d < 8.0 && (this.role === 'knight' || this.role === 'wizard')) score -= 2000.0; // Sieging Logic Override

                            if (score < bestScore) {
                                bestScore = score;
                                bestTarget = { type: 'building', obj: b };
                            }
                        }
                    }
                }

                // Apply Target
                // Only switch if we found a significantly better one OR current is invalid
                // But Hysteresis is already baked into score (-500 for current).
                // So simple comparison is safe.

                this.targetGoblin = null;
                this.targetBuilding = null;

                if (bestTarget) {
                    if (bestTarget.type === 'goblin') this.targetGoblin = bestTarget.obj;
                    else this.targetBuilding = bestTarget.obj;
                }

                // Priority 3: Raid Point (Squad OR Global)
                // Fix: Call findRaidTarget unconditionally to enable Priority Arbitration.
                const hasRaidTarget = this.findRaidTarget();

                // PRIORITY ARBITRATION: Squad vs Local
                // If we found a local target (e.g. random goblin) but it is FAR (>5.0),
                // AND we have a Squad Order (Raid Target), we should IGNORE the local target
                // and prioritize the Squad Order (Regroup/Reinforce).
                if (this.targetGoblin && hasRaidTarget) {
                    const d = this.getDistance(this.targetGoblin.gridX, this.targetGoblin.gridZ);
                    if (d > 5.0) {
                        // console.log(`[Unit ${this.id}] Prioritizing Squad Target over distant Local Target (d=${d.toFixed(1)})`);
                        this.targetGoblin = null;
                    }
                }

                if (!this.targetGoblin && !this.targetBuilding) {
                    if (hasRaidTarget) {
                        // FIX: Interrupt Loop!
                        // If we found a raid target (Squad/Global), and we are currently just wandering or patrolling,
                        // we MUST stop the current move so we can re-route to the raid point immediately.
                        // Otherwise, we finish the 10-second patrol walk before helping.
                        // We check action to avoid interrupting 'Fighting' or 'Working' (though targetGoblin check helps).
                        if (this.action === 'Idle' || this.action === 'Wandering' || this.action === 'Patrolling' || this.action === 'Migrating') {
                            if (this.isMoving) {
                                console.log(`[Unit ${this.id}] Interrupting ${this.action} for Raid Target!`);
                                this.isMoving = false; // Force stop
                                this.action = 'Approaching Target';
                            }
                        }
                    }
                }
            }
        }

        // --- ACTION LOGIC ---
        // Safety Clean: Remove dead target immediately
        if (this.targetGoblin && this.targetGoblin.isDead) {
            this.targetGoblin = null;
        }

        if (this.targetGoblin) {
            const dist = this.getDistance(this.targetGoblin.gridX, this.targetGoblin.gridZ);
            // Melee Range Relaxed: 1.8 -> 2.5 to ensure simple linear movement (which lands on integer/integer) snaps to combat.
            // Diagonal neighbor is 1.41. 2 tiles away is 2.0.
            // If we are at [10,10], target at [12,10] (dist 2.0). 
            // Previous limit 1.8 meant we had to step INTO [11,10].
            // If [11,10] is occupied by another unit, we stop at 2.0 and stare.
            // Increasing to 2.5 allows attacking from 2-tile distance (Diagonals/crowds).
            let range = 2.5;
            if (this.role === 'wizard') range = 5.5;

            if (dist <= range) {
                this.action = "Fighting";
                this.isMoving = false;
                this.attackGoblin(this.targetGoblin);

                // Continuous Signal Refresh (Fix for Reinforcements not coming)
                // Ensure we broadcast "I am fighting here!" continuously so squad signal never expires.
                if (this.game && this.squadId) {
                    this.reportEnemy(this.targetGoblin);
                }

                this.chaseTimer = 0;
            } else {
                // Chase
                this.chaseTimer = (this.chaseTimer || 0) + deltaTime;

                // RE-EVALUATE TARGET (Fix for "Combat Moving" to wrong place/nowhere)
                // If we are chasing someone FAR away (>10 tiles), check if Squad has a better target.
                // This prevents getting locked onto a random map-edge goblin while the main battle rages elsewhere.
                if (dist > 10.0 && this.chaseTimer > 2.0) {
                    // Check if there is a Raid Target (Squad or Global)
                    // matches logic in updateLogic structure but forces an interrupt check
                    if (this.findRaidTarget()) {
                        console.log(`[Unit ${this.id}] Abandoning distant chase (d=${dist.toFixed(1)}) for Squad Target.`);
                        this.targetGoblin = null; // Drop current target
                        this.chaseTimer = 0;
                        // Next frame, logic will pick up targetRaidPoint and move there.
                        return; // End this frame's logic
                    }
                }

                // Periodic Path Verification (Every 3s)
                // Prevents running along the shoreline indefinitely ("Not giving up")
                // If we have been chasing for 3s WITHOUT a path (Linear Mode), force a check.
                if (this.chaseTimer > 3.0 && !this.path) {
                    // console.log(`[Unit ${this.id}] Chase verification (3s). Force Pathfinding.`);
                    this.attemptPathfinding(time);
                    this.chaseTimer = 0;
                }

                // STAGNATION CHECK (Local Minima Escape)
                // If we are chasing but distance isn't improving, we are likely stuck in a "Dejima" (local trap).
                // Coastline logic keeps us moving, but we might oscillate.
                const currentMin = this.minDistToTarget || Infinity;
                if (dist < currentMin - 0.5) {
                    this.minDistToTarget = dist;
                    this.pathStagnation = 0;
                } else {
                    // Not improving significantly
                    this.pathStagnation = (this.pathStagnation || 0) + deltaTime;
                }

                if (this.pathStagnation > 2.0) { // Reduced from 5.0 to 2.0 for faster "Give Up" on island targets
                    // console.log(`[Unit ${this.id}] Path Stagnation detected. Dist: ${dist.toFixed(1)}. Force Pathfinding.`);
                    this.attemptPathfinding(time);
                    this.pathStagnation = 0;
                    this.minDistToTarget = dist; // Reset baseline to avoid immediate re-trigger
                }

                if (this.isMoving) {
                    // Logic to update path if target moves significantly?
                    // Since we move step-by-step, we will reach the tile then re-evaluate.
                    // No need to interrupt mid-step (1 tile) unless dire.
                    // Interrupting causes jitter.
                }
                if (!this.isMoving && this.targetGoblin) {
                    this.action = "Chasing";
                    this.triggerMove(this.targetGoblin.gridX, this.targetGoblin.gridZ, time);
                    this.moveInterval = 0;
                }
            }
        } else if (this.targetBuilding) {
            const dist = this.getDistance(this.targetBuilding.gridX, this.targetBuilding.gridZ);
            if (dist <= 2.0) {
                this.action = "Sieging";
                this.attackBuilding(this.targetBuilding);
            } else {
                // STAGNATION CHECK
                const currentMin = this.minDistToTarget || Infinity;
                if (dist < currentMin - 0.5) {
                    this.minDistToTarget = dist;
                    this.pathStagnation = 0;
                } else {
                    this.pathStagnation = (this.pathStagnation || 0) + deltaTime;
                }

                if (this.pathStagnation > 5.0) {
                    console.log(`[Unit ${this.id}] Path Stagnation detected (Building). Dist: ${dist.toFixed(1)}. Force A*.`);
                    this.attemptPathfinding(time);
                    this.pathStagnation = 0;
                    this.minDistToTarget = dist;
                }

                if (!this.isMoving && time - this.lastTime > this.moveInterval) {
                    if (this.targetBuilding) { // Safety Check
                        this.action = (dist > 20.0) ? "Travelling" : "Approaching Target";
                        this.triggerMove(this.targetBuilding.gridX, this.targetBuilding.gridZ, time);
                    } else {
                        // Lost target?
                        this.action = "Idle";
                    }
                }
            }
        } else if (this.targetRaidPoint) {
            const dist = this.getDistance(this.targetRaidPoint.x, this.targetRaidPoint.z);
            // FIX: Arrival threshold must match Acquisition (>2.0).
            // Was 5.0, caused oscillation (Acquire > 2.0, Drop <= 5.0 -> Loop 3.0 -> Stutter).
            // Now strict 2.0.
            if (dist <= 2.0) {
                this.searchSurroundings(this.gridX, this.gridZ);
                this.targetRaidPoint = null;
            } else {
                // STAGNATION CHECK
                const currentMin = this.minDistToTarget || Infinity;
                if (dist < currentMin - 0.5) {
                    this.minDistToTarget = dist;
                    this.pathStagnation = 0;
                } else {
                    this.pathStagnation = (this.pathStagnation || 0) + deltaTime;
                }

                if (this.pathStagnation > 5.0) {
                    console.log(`[Unit ${this.id}] Path Stagnation detected (RaidPoint). Dist: ${dist.toFixed(1)}. Force A*.`);
                    this.attemptPathfinding(time);
                    this.pathStagnation = 0;
                    this.minDistToTarget = dist;
                }

                // FIX: If distance is large (>15), DO NOT attempt linear move blindly.
                // This prevents walking into water towards an island and getting stuck.
                // Force Pathfinding first.
                if (dist > 15.0 && !this.path) {
                    this.attemptPathfinding(time);
                    // If pathfinding finds path, next frame we follow it.
                    // If falls (unreachable), itブラックlists and aborts.
                    // Do NOT call triggerMove until path found.
                } else if (!this.isMoving && time - this.lastTime > this.moveInterval) {
                    this.checkArrivalAtRaidPoint(); // Check BEFORE triggering new move
                    if (this.targetRaidPoint) {
                        this.triggerMove(this.targetRaidPoint.x, this.targetRaidPoint.z, time);
                    }
                }
            }


            // --- MIGRATION LOGIC (Persistence) ---
        } else if (this.action === 'Migrating' && this.migrationTarget) {
            const dist = this.getDistance(this.migrationTarget.x, this.migrationTarget.z);
            if (dist <= 2.0) {
                // Arrived Manually (if onMoveFinished didn't catch it)
                this.onMoveFinished(time);
            } else {
                // STAGNATION / RETRY CHECK
                if (!this.isMoving && time - this.lastTime > this.moveInterval) {
                    // Force move again if stopped
                    console.log(`[Unit ${this.id}] Resume Migration to ${this.migrationTarget.x},${this.migrationTarget.z}`);

                    // Force Pathfinding if far
                    if (dist > 15.0 && !this.path) {
                        this.attemptPathfinding(time);
                    } else {
                        this.triggerMove(this.migrationTarget.x, this.migrationTarget.z, time);
                    }
                }
            }

            // --- WORKER JOB LOGIC ---
        } else if (this.role === 'worker' && this.targetRequest) {
            if (this.isSleeping) this.isSleeping = false; // Force Wake Up

            // INTERRUPT WANDER / MIGRATION
            // If we are moving but NOT for work/fight, stop immediately to attend job.
            // CAUTION: Do NOT interrupt if we are ALREADY 'Approaching Job' or 'Working', otherwise we oscillate!
            if (this.isMoving && (this.action === 'Idle' || this.action === 'Moving' || this.action === 'Migrating')) {
                console.log(`[Unit ${this.id}] Interrupting movement for Job ${this.targetRequest.type}`);
                this.isMoving = false;
                this.moveTimer = 0; // Reset interpolation
                this.lastMoveAttempt = 0; // Allow immediate retry
            }

            const dist = this.getDistance(this.targetRequest.x, this.targetRequest.z);
            if (dist <= 2.0) {
                this.action = "Working";
                this.isMoving = false; // Stop moving to work
                // Execute
                // Execute
                if (window.game) window.game.completeRequest(this, this.targetRequest);
                this.targetRequest = null;

                // JOB CHAINING: Immediately look for another job nearby
                // prevents walking away when there is more work 2 tiles away.
                // We use findBestRequest which searches globally/nearby.
                if (window.game) {
                    const nextReq = window.game.findBestRequest(this);
                    if (nextReq && window.game.claimRequest(this, nextReq)) {
                        this.targetRequest = nextReq;
                        this.action = 'Approaching Job';
                        console.log(`[Unit ${this.id}] Chained Job ${nextReq.type}`);
                    } else {
                        this.action = "Idle";
                    }
                } else {
                    this.action = "Idle";
                }
            } else {
                this.action = "Working";
                if (!this.isMoving && time - (this.lastMoveAttempt || 0) > 1000) {
                    this.lastMoveAttempt = time;
                    this.triggerMove(this.targetRequest.x, this.targetRequest.z, time);

                    // CRITICAL FIX: executeMove sets action='Moving'.
                    // We must force it to 'Approaching Job' so our interrupt logic ignores it next frame.
                    if (this.isMoving) {
                        this.action = 'Approaching Job';
                    }

                    // Track failures to start moving (e.g. across water/cliffs)
                    if (!this.isMoving) {
                        this.jobMoveFailures = (this.jobMoveFailures || 0) + 1;
                        if (this.jobMoveFailures > 5) {
                            console.warn(`Unit ${this.id} failed to reach job ${this.targetRequest.id} after 5 attempts. Releasing.`);
                            if (window.game) window.game.releaseRequest(this, this.targetRequest);
                            this.targetRequest = null;
                            this.action = 'Idle';
                            this.jobMoveFailures = 0;
                        }
                    } else {
                        this.jobMoveFailures = 0;
                    }
                }
            }

            // --- IDLE / JOB SEARCH ---
        } else {
            // If idle, look for a job (Workers Only)
            if (this.role === 'worker' && !this.targetRequest && window.game) {
                // Throttle job search
                // Increased from 0.1 to 0.5 for faster reaction (User Request: "Too slow")
                if (Math.random() < 0.5) {
                    const req = window.game.findBestRequest(this);
                    if (req) {
                        if (window.game.claimRequest(this, req)) {
                            this.targetRequest = req;
                            console.log(`Unit ${this.id} claimed job ${req.type}`);
                        }
                    }
                }
            }
        }

        // Safety Reset
        if ((this.action === 'Chasing' || this.action === 'Fighting') && !this.targetGoblin && !this.targetBuilding) {
            this.isMoving = false;
            this.action = 'Idle';
        }

        this.gatherResources(time);

        // --- IDLE / WANDER / STAGNATION ---

        // Stuck Watchdog (Ghost Move)
        // Stuck Watchdog (Ghost Move) - REMOVED (Caused Jitter on slow terrain)
        // Lerp movement doesn't update gridX until end, so this always triggered for >3s moves.
        this.moveStuckTimer = 0;

        // Stagnation Logic
        if (this.lastGridX === this.gridX && this.lastGridZ === this.gridZ && !this.isSleeping && !this.isMoving) {
            this.stagnationTimer += deltaTime;
        } else {
            this.lastGridX = this.gridX;
            this.lastGridZ = this.gridZ;
            this.stagnationTimer = 0;
        }

        if (this.stagnationTimer > 10.0) {
            this.moveRandomly(time);
            if (this.stagnationTimer > 20.0) {
                this.migrate(time); // Use walking migrate
                this.stagnationTimer = 0;
            }
            return;
        }

        // Wander / Night Logic
        if (!this.isMoving && !this.targetGoblin && !this.targetBuilding && !this.targetRaidPoint && !this.targetRequest) {
            const canSleep = (this.role === 'worker' || this.role === 'fisher' || this.role === 'hunter');
            if (isNight && canSleep) {
                const cell = this.terrain.grid[this.gridX][this.gridZ];
                const isShelter = cell.hasBuilding && cell.building && (cell.building.type === 'house' || cell.building.type === 'castle');
                if (isShelter) {
                    if (!this.isSleeping) {
                        console.log(`[Unit ${this.id}] Sleeping`);
                        this.isSleeping = true;
                    }
                    return;
                } else {

                    // Go Home Logic
                    if (!this.isMoving && time - this.lastTime > this.moveInterval) {
                        let targetShelter = this.homeBase;

                        // Commitment Logic: Use cached target if valid
                        if (!targetShelter) {
                            if (this.nightShelterTarget && this.nightShelterTarget.userData.hp > 0) {
                                // Check if still exists in world (simple check via hp usually enough, or use uniqueId lookup)
                                targetShelter = this.nightShelterTarget;
                            } else {
                                targetShelter = this.findNearestShelter();
                                this.nightShelterTarget = targetShelter;
                            }
                        }

                        if (targetShelter) {
                            this.action = "Going Home";
                            this.triggerMove(targetShelter.userData.gridX, targetShelter.userData.gridZ, time);
                            return; // Priority
                        } else {
                            // No shelter found? Wander.
                            this.nightShelterTarget = null;
                        }
                    }
                }

            } else {
                if (this.isSleeping) this.isSleeping = false;
            }
        }

        // Active Wander/Work
        if (!this.isMoving && time - this.lastTime > this.moveInterval) {
            if (this.id === 0 && this.debugFrame % 60 === 0) console.log(`[Unit Debug] Executing Logic. Role: ${this.role}`);
            if (this.role === 'worker') {
                const cell = this.terrain.grid[this.gridX][this.gridZ];
                if (cell && cell.moisture !== 0.5 && Math.random() < 0.1) {
                    this.improveLand(time);
                } else {
                    this.moveRandomly(time);
                }
            } else if (this.role === 'knight' || this.role === 'wizard') {
                const found = this.findRaidTarget();
                if (!found) this.exploreSurroundings(time);
                if (this.targetRaidPoint) {
                    this.triggerMove(this.targetRaidPoint.x, this.targetRaidPoint.z, time);
                } else {
                    this.patrol(time);
                }
            } else {
                this.moveRandomly(time);
            }
            this.lastTime = time;
            this.moveInterval = 2000 + Math.random() * 3000;
        }
    }


    searchForHut(x, z) {
        // Wrapper for finding nearby buildings. 
        // Logic already exists in findTargetBuilding, which searches near 'this' unit.
        // Since Unit is at (x,z) (melee range), this works.
        this.findTargetBuilding(40); // Scan within 40 tiles
    }

    findTargetBuilding(range) {
        // Search for 'goblin_hut' or 'cave' nearby
        if (!this.terrain.buildings) return;
        const buildings = this.terrain.buildings;
        let nearest = null;
        let minDist = Infinity; // Global Search (Soldiers travel far)
        let foundType = null;

        const limitRange = (range !== undefined) ? range : Infinity;

        for (const b of buildings) {
            // Workers ONLY target huts, not Caves (Caves require explosives/Knights?)
            // Actually user just said "Goblin Huts". Let's restrict workers to huts.
            if (this.role === 'worker' && b.type !== 'goblin_hut') continue;

            if (b.type === 'goblin_hut' || b.type === 'cave') {
                const dist = this.getDistance(b.gridX, b.gridZ);

                if (dist > limitRange) continue;

                // Prefer closer, but take any
                if (dist < minDist) {
                    minDist = dist;
                    nearest = b;
                    foundType = b.type;
                }
            }
        }

        // Debug log (Throttle)
        if (this.role === 'knight' && Math.random() < 0.001) {
            console.log(`[Unit Debug] Targeted: ${this.targetGoblin ? 'Goblin' : (this.targetBuilding ? this.targetBuilding.type : 'None')}`);
        }

        if (nearest && foundType) {
            // console.log(`Unit ${this.id} targets enemy base: ${nearest.type} at ${nearest.gridX},${nearest.gridZ}`);
            this.targetBuilding = nearest;
            this.reportEnemy(nearest); // Report Sighting!
        }
    }

    reportEnemy(target) {
        if (!target) return;

        const x = target.gridX;
        const z = target.gridZ;

        // 1. Report to Squad (Priority)
        if (this.squadId && window.game) {
            window.game.reportSquadTarget(this.squadId, x, z);
        } else if (window.game) {
            // If no squad, report directly to Global
            window.game.reportGlobalBattle(x, z);
        }

        // 2. Report to Global Memory (Legacy/Freelancer backup)
        // This helps units without squads or if squad logic fails
        if (this.game && this.game.battleMemory) {
            this.game.battleMemory.reportRaid(x, z, (this.game.gameTotalTime || Date.now()));
        }
    }

    findRaidTarget() {
        // PRIORITY 1: Check Squad Orders
        if (this.squadId && window.game) {
            const squad = window.game.getSquad(this.squadId);
            if (squad && squad.target) {
                const age = Date.now() - squad.target.time;

                // Debug Log for Stagnation
                if (Math.random() < 0.05 && this.role === 'knight') {
                    const d = this.getDistance(squad.target.x, squad.target.z);
                    console.log(`[Unit ${this.id} SquadDebug] ID:${this.squadId} Target:${squad.target.x},${squad.target.z} Dist:${d.toFixed(1)} Age:${age}ms Reachable:${this.isReachable(squad.target.x, squad.target.z)} `);
                }

                if (age < 30000) { // Valid for 30s
                    // Check if close enough to be "arrived" (to stop jitter)
                    const d = this.getDistance(squad.target.x, squad.target.z);
                    // Tightened threshold from 5.0 to 2.0 to force units closer to the fight
                    if (d > 2.0) {
                        // Check reachability
                        if (this.isReachable(squad.target.x, squad.target.z)) {
                            this.targetRaidPoint = { x: squad.target.x, z: squad.target.z };
                            return true;
                        } else {
                            // UNREACHABLE? Trying Proxy Target!
                            // If target is in another region (e.g. across water), find closest point in MY region.
                            const myCell = this.terrain.grid[this.gridX][this.gridZ];
                            if (myCell && myCell.regionId > 0) {
                                const proxy = this.terrain.findClosestReachablePoint(squad.target.x, squad.target.z, myCell.regionId);
                                if (proxy) {
                                    // console.log(`[Unit ${this.id}] Squad Target Unreachable. Moving to Proxy: ${proxy.x},${proxy.z}`);
                                    this.targetRaidPoint = { x: proxy.x, z: proxy.z };
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }

        // PRIORITY 2: Total Mobilization (Global Hotspots)
        // Only for Combat Units
        if ((this.role === 'knight' || this.role === 'wizard') && window.game && window.game.battleHotspots && window.game.battleHotspots.length > 0) {
            const now = Date.now();
            // Find closest reachable hotspot
            let bestSpot = null;
            let minD = Infinity;

            for (const spot of window.game.battleHotspots) {
                if (now - spot.time > 30000) continue; // Skip old

                let targetX = spot.x;
                let targetZ = spot.z;
                let d = this.getDistance(targetX, targetZ);

                // Check Region & Proxy Logic
                if (!this.isReachable(targetX, targetZ)) {
                    // Try Proxy
                    let proxyFound = false;
                    const myCell = this.terrain.grid[this.gridX][this.gridZ];
                    if (myCell && myCell.regionId > 0) {
                        const proxy = this.terrain.findClosestReachablePoint(targetX, targetZ, myCell.regionId);
                        if (proxy) {
                            targetX = proxy.x;
                            targetZ = proxy.z;
                            d = this.getDistance(targetX, targetZ);
                            proxyFound = true;
                        }
                    }
                    if (!proxyFound) continue; // Truly unreachable
                }

                if (d < 2.0) continue; // Already there

                if (d < minD) {
                    minD = d;
                    bestSpot = { x: targetX, z: targetZ };
                }
            }

            if (bestSpot) {
                this.targetRaidPoint = { x: bestSpot.x, z: bestSpot.z };
                return true;
            }
        }

        // PRIORITY 3: Global Memory (Legacy/Fallback)
        let memories = [];
        const currentTime = (this.game) ? this.game.gameTotalTime : Date.now();

        if (this.game && this.game.battleMemory) {
            memories = this.game.battleMemory.getPriorities(currentTime);
        }

        if (!memories || memories.length === 0) {
            return;
        }

        let nearest = null;
        let minDist = Infinity;

        memories.forEach(p => {
            let targetX = p.x;
            let targetZ = p.z;
            let dist = this.getDistance(targetX, targetZ);

            // HUGE CHANGE: Do not target points we are already at!
            // Legacy check was < 8.0, but if we use Proxy, we might be AT proxy.
            if (dist < 4.0) return;

            // Check ignore list by coord
            if (this.ignoredTargets && this.ignoredTargets.has(`${p.x},${p.z}`)) return;

            // REGION CHECK (Added by User Request)
            // Ensure the raid point is reachable from current position
            if (this.terrain.grid) {
                const W = this.terrain.logicalWidth || 80;
                const D = this.terrain.logicalDepth || 80;

                // Safe Wrap for Grid Access
                let px = Math.round(targetX);
                let pz = Math.round(targetZ);
                px = ((px % W) + W) % W;
                pz = ((pz % D) + D) % D;

                const mCell = this.terrain.grid[this.gridX][this.gridZ];
                const tCell = (this.terrain.grid[px]) ? this.terrain.grid[px][pz] : null;

                if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
                    // Try Proxy Logic Here Too
                    const proxy = this.terrain.findClosestReachablePoint(targetX, targetZ, mCell.regionId);
                    if (proxy) {
                        targetX = proxy.x;
                        targetZ = proxy.z;
                        dist = this.getDistance(targetX, targetZ);
                    } else {
                        return; // Skip unreachable island
                    }
                }
            }

            if (dist < minDist) {
                minDist = dist;
                nearest = { x: targetX, z: targetZ };
            }
        });

        if (nearest) {
            this.targetRaidPoint = nearest;
            return true;
        }
        return false;
    }

    findNearestShelter() {
        if (!this.terrain || !this.terrain.buildings) return null;

        let nearest = null;
        let minDist = Infinity;

        for (const b of this.terrain.buildings) {
            // Check ignore
            if (this.ignoredTargets && this.ignoredTargets.has(b.id)) continue;
            if (this.ignoredTargets && this.ignoredTargets.has(`${b.gridX},${b.gridZ}`)) continue;

            if (b.type === 'house' || b.type === 'castle') {
                if (b.userData && b.userData.hp > 0) {
                    const d = this.getDistance(b.gridX, b.gridZ);
                    if (d < minDist) {
                        minDist = d;
                        nearest = b;
                    }
                }
            }
        }
        return nearest;
    }

    exploreSurroundings(time) {
        // No memory target. Pick a random patrol point on the map.
        // This simulates "Exploration" and triggers searchSurroundings upon arrival.
        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        // Try to pick a spot somewhat far away to encourage movement?
        // Or just random.
        const rx = Math.floor(Math.random() * logicalW);
        const rz = Math.floor(Math.random() * logicalD);

        // Don't pick water?
        const h = this.terrain.getTileHeight(rx, rz);
        if (h <= 0) return; // Try again next frame

        // REGION CHECK for Exploration
        // Ensure the random point is reachable
        if (this.terrain.grid) {
            const mCell = this.terrain.grid[this.gridX][this.gridZ];
            const tCell = this.terrain.grid[rx][rz];
            if (mCell && tCell && mCell.regionId !== tCell.regionId) {
                // Different region, impossible to reach.
                // Fail and try again later.
                return;
            }
        }

        // Don't pick too close (avoid immediate loop)
        const dist = this.getDistance(rx, rz);
        if (dist < 15.0) return; // Too close

        this.targetRaidPoint = { x: rx, z: rz, priority: 1 };
        console.log(`Unit ${this.id} exploring to ${rx},${rz}`);
    }

    checkArrivalAtRaidPoint() {
        if (!this.targetRaidPoint) return;
        const dist = this.getDistance(this.targetRaidPoint.x, this.targetRaidPoint.z);
        if (dist <= 2.0) { // Standardized to 2.0 (was 3.0)
            console.log(`[Unit ${this.id}] Arrived at Raid Point. Scanning...`);
            this.searchSurroundings(this.gridX, this.gridZ);
            // If search did not lock onto a target, clear the raid point to prevent stuck state
            if (!this.targetGoblin && !this.targetBuilding) {
                console.log(`[Unit ${this.id}] Nothing found at Raid Point. Clearing Shared Memory.`);

                // Clear from Shared Memory (Global or Squad)
                if (this.homeBase && this.homeBase.userData && this.homeBase.userData.memory) {
                    this.homeBase.userData.memory.reportClear(this.targetRaidPoint.x, this.targetRaidPoint.z);
                } else if (this.game && this.game.battleMemory) {
                    this.game.battleMemory.reportClear(this.targetRaidPoint.x, this.targetRaidPoint.z);
                }

                this.targetRaidPoint = null;
            }
        }
    }

    searchSurroundings(x, z, goblins) {
        // Active scan for Goblins OR Buildings
        if (!this.game) return;

        // Ensure we have candidates for finding goblins
        const goblinCandidates = goblins || (window.game && window.game.goblinManager ? window.game.goblinManager.goblins : []);

        if (this.terrain && this.terrain.findBestTarget) {
            // 1. Goblins (Optimized)
            // Use Role-based range (Knights/Wizards can see farther)
            const range = (this.role === 'knight' || this.role === 'wizard') ? 50 : 20;

            const goblin = this.terrain.findBestTarget('goblin', x, z, range, (g, dist) => {
                const now = window.game ? window.game.gameTotalTime : Date.now();

                // SELF DEFENSE OVERRIDE: If super close (< 5.0), ignore the Ignore List!
                const isVeryClose = (dist < 5.0);

                if (!isVeryClose) {
                    if (this.ignoredTargets.has(g.id) && now < this.ignoredTargets.get(g.id)) return Infinity;
                }
                if (g.isDead) return Infinity;

                // REGION CHECK
                if (this.terrain.grid) {
                    const mCell = this.terrain.grid[this.gridX][this.gridZ];
                    const tCell = this.terrain.grid[g.gridX][g.gridZ];
                    if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
                        return Infinity; // Unreachable
                    }
                }

                // REGION CHECK
                if (!isVeryClose && this.terrain.grid) { // Skip region check if self-defense
                    const mCell = this.terrain.grid[this.gridX][this.gridZ];
                    const tCell = this.terrain.grid[g.gridX][g.gridZ];
                    if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
                        return Infinity; // Unreachable
                    }
                }

                return dist; // Simple closest check
            }, goblinCandidates); // Pass candidates!

            if (goblin) {
                this.targetGoblin = goblin;
                this.reportEnemy(goblin);
                console.log(`Unit ${this.id} found Goblin via Spatial Search!`);
                return;
            }

            // 2. Buildings (Optimized)
            // Range 12. Types: goblin_hut or cave.
            const building = this.terrain.findBestTarget('building', x, z, 12, (b, dist) => {
                const now = window.game ? window.game.gameTotalTime : Date.now();
                const id = b.userData ? (b.userData.id || b.id) : b.id;
                if (id && this.ignoredTargets.has(id) && now < this.ignoredTargets.get(id)) return Infinity;

                if (b.userData.type === 'goblin_hut' || b.userData.type === 'cave') {
                    // REGION CHECK
                    if (this.terrain.grid) {
                        const mCell = this.terrain.grid[this.gridX][this.gridZ];
                        const tCell = this.terrain.grid[b.gridX][b.gridZ];
                        if (mCell && tCell && mCell.regionId !== tCell.regionId && mCell.regionId > 0 && tCell.regionId > 0) {
                            return Infinity;
                        }
                    }
                    return dist;
                }
                return Infinity; // Ignore other buildings
            });

            if (building) {
                console.log(`Unit ${this.id} found Base via Spatial Search!`);
                // Note: Logic below didn't set targetBuilding explicitly in original code?
                // Original: Just logged "found Base".
                // Ah, Unit.js logic updates "targetRaidPoint" via report?
                // Actually, original code (Step 1352) JUST RETURNED?
                // Wait: line 876: `return;`.
                // It seems `searchSurroundings` is just a Trigger?
                // But `targetGoblin` IS set.
                // For buildings, it only logs. Maybe `reportRaid` is handled elsewhere?
                // Actually, line 860 calls `reportEnemy`.
                // For buildings, original code did NOTHING but log.
                // I will replicate that behavior for safety, or improve it.
                // If I return building, I should probably do something.
                // But strictly replacing:
                return;
            }
        } else {
            // Fallback (or Error if terrain incomplete mock)
        }
    }

    patrol(time) {
        // Go to a random building to "guard" it, or just wander if none
        if (this.terrain.buildings && this.terrain.buildings.length > 0) {
            // Pick random building
            const r = Math.floor(Math.random() * this.terrain.buildings.length);
            const b = this.terrain.buildings[r];

            // Go near it
            // Don't go INSIDE, go next to it.
            // Simple: Target its location.
            // Dist check?
            const dx = Math.abs(this.gridX - b.gridX);
            const dz = Math.abs(this.gridZ - b.gridZ);

            // If already near, wander locally
            if (dx < 5 && dz < 5) {
                this.moveRandomly(time);
            } else {
                this.triggerMove(b.gridX, b.gridZ, time);
            }
        } else {
            this.moveRandomly(time);
        }
    }

    // updateMovement is inherited from Entity.
    // We implement hooks for Unit-specific logic.

    onMoveFinished(time) {
        // Reset limbs
        this.limbs.leftArm.x = 0;
        this.limbs.rightArm.x = 0;
        this.limbs.leftLeg.x = 0;
        this.limbs.rightLeg.x = 0;

        const built = this.tryBuildStructure(time);
        if (built) {
            // If we successfully built something, STOP MIGRATING. We found a home/job.
            if (this.action === 'Migrating') {
                console.log(`Unit ${this.id} built structure during migration. Stopping.`);
                this.action = 'Idle';
                this.migrationTarget = null;
                this.migrationTimer = 0;
            }
            this.buildStagnationCount = 0;
        } else {
            // Check based on Target presence, not Action string (since executeMove overwrites action)
            if (this.migrationTarget) {
                if (this.role === 'worker') {
                    // Workers searched for land but failed to build. Try nearby.
                    console.log(`Unit ${this.id} (Worker) migration target invalid for build. Searching nearby...`);
                    this.moveRandomly(time);

                    // SAFETY: If moveRandomly failed to trigger move (stuck in corner), FORCE IDLE.
                    if (!this.isMoving) {
                        this.action = 'Idle';
                    }
                } else {
                    // Knights/Wizards just finished their "Migration" travel. 
                    // They don't build. Just stop here.
                    console.log(`Unit ${this.id} (${this.role}) finished migrating. Resuming Idle.`);
                    this.action = 'Idle';
                    this.migrationTarget = null;
                }
                this.buildStagnationCount = 0;
            } else {
                this.buildStagnationCount = (this.buildStagnationCount || 0) + 1;
                if (this.buildStagnationCount > 5) {
                    console.log(`Unit ${this.id} stuck/stagnant (No Build). Migrating...`);
                    this.migrate(time);
                    this.buildStagnationCount = 0;
                }
            }
        }
    }

    onMoveStep(progress) {
        // Animate limbs
        const limbAngle = Math.sin(progress * Math.PI * 4) * 0.5;
        this.limbs.leftArm.x = limbAngle;
        this.limbs.rightArm.x = -limbAngle;
        this.limbs.leftLeg.x = -limbAngle;
        this.limbs.rightLeg.x = limbAngle;

        // Mesh sync handled by Entity.updateMovement -> updatePosition
        if (this.mesh) {
            this.mesh.position.copy(this.position);
            if (this.rotationY !== undefined) this.mesh.rotation.y = this.rotationY;
        }
    }

    triggerMove(tx, tz, time) {
        // Use Actor.smartMove for robust movement (Pathing + Linear Fallback + Region Check)
        // Note: smartMove handles wrapping, reachability, and A* pathfinding
        const moved = this.smartMove(tx, tz, time);

        if (moved) {
            // Success
            this.stuckCount = 0;
        } else {
            // Blocked / Failed
            // Unit specific stuck handling
            if (!this.isMoving) {
                this.stuckCount = (this.stuckCount || 0) + 1;
                // Only give up after significant failures (e.g. 10 frames of blockage)
                // This prevents giving up on transient collisions, but ensures we eventually drop unreachable targets.
                if (this.stuckCount > 10) {
                    this.handleStuck();
                }
            }
        }
    }

    handleStuck() {
        // Give up logic
        const time = (window.game) ? window.game.gameTotalTime : 0;
        console.log(`Unit ${this.id} stuck. Handling stuck state...`);

        this.path = null;

        // Ignore current targets
        const ignoreDuration = time + 5000;
        if (this.targetGoblin) {
            this.ignoredTargets.set(this.targetGoblin.id, ignoreDuration);
            this.ignoredTargets.set(`${this.targetGoblin.gridX},${this.targetGoblin.gridZ}`, ignoreDuration);
            this.targetGoblin = null;
        }
        if (this.targetBuilding) {
            this.ignoredTargets.set(this.targetBuilding.id, ignoreDuration);
            this.ignoredTargets.set(`${this.targetBuilding.gridX},${this.targetBuilding.gridZ}`, ignoreDuration);
            this.targetBuilding = null;
        }
        if (this.targetRaidPoint) {
            this.ignoredTargets.set(`${this.targetRaidPoint.x},${this.targetRaidPoint.z}`, ignoreDuration);
            this.targetRaidPoint = null;
        }

        this.stuckCount = 0;
        this.action = "Idle";
        this.isMoving = false;

        // Revert to Random Move or Idle
        console.warn(`[Unit ${this.id}] Stuck Recovery triggered. Resetting to Idle.`);
    }

    canMoveTo(x, z) {
        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        // Wrap logic for checking? (Ideally we shouldn't move off-bounds without wrap handling in caller)
        // But let's assume raw coords for check, wrap handled in execute
        let checkX = x;
        let checkZ = z;
        if (checkX < 0) checkX = logicalW - 1;
        if (checkX >= logicalW) checkX = 0;
        if (checkZ < 0) checkZ = logicalD - 1;
        if (checkZ >= logicalD) checkZ = 0;


        const currentHeight = this.terrain.getTileHeight(this.gridX, this.gridZ);
        const targetHeight = this.terrain.getTileHeight(checkX, checkZ);

        if (targetHeight <= 0) {
            const now = (this.game) ? this.game.gameTotalTime : Date.now();
            if (now - (this.lastWaterLogTime || 0) > 5000) {
                console.log(`[Unit ${this.id}] Blocked by Water at ${checkX},${checkZ} H:${targetHeight}`);
                this.lastWaterLogTime = now;
            }
            return false; // Water
        }
        if (targetHeight > 8) {
            console.log(`[Unit ${this.id}] Moving onto Rock at ${checkX},${checkZ} H:${targetHeight} (Speed Penalty)`);
            // return false; // Rock - REVERTED per User Request (Slow movement)
        }

        // Slope check
        if (Math.abs(targetHeight - currentHeight) > 2.0) {
            console.log(`[Unit ${this.id}] Blocked by Slope at ${checkX},${checkZ} H:${currentHeight}->${targetHeight}`);
            return false;
        }

        // Building check
        const cell = this.terrain.grid[checkX][checkZ];
        if (cell.hasBuilding && cell.building) {
            // User Request: Allow passing through buildings
            return true;
        }
        // Implicit allow if no building
        return true;
    }

    /* 
    // DUPLICATE CODE REMOVED
    updateLogic(time, deltaTime, units, buildings) {
       // ...
    }
    */

    // ...

    executeMove(nextX, nextZ, time) {
        // ... Wrap logic (lines 1069-1076 kept) ...
        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;
        if (nextX < 0) nextX = logicalW - 1;
        if (nextX >= logicalW) nextX = 0;
        if (nextZ < 0) nextZ = logicalD - 1;
        if (nextZ >= logicalD) nextZ = 0;

        // Use Entity base startMove for state setup
        super.startMove(nextX, nextZ, time);
        // this.isMoving = true; // Fallback removed
        this.action = "Moving";

        // Speed Logic (Can override Entity defaults)
        const currentHeight = this.terrain.getTileHeight(this.gridX, this.gridZ);
        const targetHeight = this.terrain.getTileHeight(nextX, nextZ);
        const heightDiff = Math.abs(targetHeight - currentHeight);

        // Smoother Slope Penalty
        // Base Speed: 600ms (approx 1.6 tiles/sec)
        // Slope Penalty: +1000ms per height unit
        // High Altitude (>8): +2000ms flat penalty (Thin air / Snow)
        let base = 600;
        if (targetHeight > 8) base += 2000;

        this.moveDuration = base + (heightDiff * 1000);

        // Reset stuck count
        this.stuckCount = 0;
    }

    gatherResources(time) {
        if (time - this.lastGatherTime < 5000) return;
        this.lastGatherTime = time;

        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        let foundWater = false;
        let foundForest = false;

        const sampleOffsets = [
            { x: 0, z: 0 },
            { x: 1, z: 0 }, { x: -1, z: 0 }, { x: 0, z: 1 }, { x: 0, z: -1 },
            { x: 4, z: 0 }, { x: -4, z: 0 }, { x: 0, z: 4 }, { x: 0, z: -4 }
        ];

        for (const off of sampleOffsets) {
            let nx = this.gridX + off.x;
            let nz = this.gridZ + off.z;

            // Wrap
            if (nx < 0) nx = logicalW + nx;
            if (nx >= logicalW) nx = nx - logicalW;
            if (nz < 0) nz = logicalD + nz;
            if (nz >= logicalD) nz = nz - logicalD;

            nx = (nx % logicalW + logicalW) % logicalW;
            nz = (nz % logicalD + logicalD) % logicalD;

            const h = this.terrain.getTileHeight(nx, nz);

            if (h <= 0) foundWater = true;
            else if (h > 4 && h <= 8) foundForest = true;

            if (foundWater && foundForest) break;
        }

        if (window.game && window.game.resources) {
            if (foundWater) {
                const amount = (this.role === 'fisher') ? 3.0 : 1.0;
                window.game.resources.fish += amount;
            }
            if (foundForest) {
                const amount = (this.role === 'hunter') ? 3.0 : 1.0;
                window.game.resources.meat += amount;
            }
        }
    }

    findTargetGoblin(goblins) {
        if (!goblins || goblins.length === 0) return;

        let nearest = null;
        let minScore = Infinity;

        const maxDist = (this.role === 'knight' || this.role === 'wizard') ? 50 : 15;

        for (const goblin of goblins) {
            if (goblin.isDead) continue;
            if (this.ignoredTargets && this.ignoredTargets.has(goblin.id)) continue;

            // Region Check (CRITICAL FIX)
            const myCell = this.terrain.grid[this.gridX][this.gridZ];
            const targetCell = this.terrain.grid[goblin.gridX][goblin.gridZ];

            if (myCell && targetCell) {
                const myRegion = myCell.regionId;
                const targetRegion = targetCell.regionId;

                if (myRegion > 0) {
                    // Land-to-Land: Must match
                    if (targetRegion !== myRegion) continue;
                } else {
                    // Water-to-Land: Strictly Forbidden (Blindness)
                    // Prevents "Seeing Island from Shore"
                    if (targetRegion > 0) continue;
                }
            }

            const dx = this.gridX - goblin.gridX;
            const dz = this.gridZ - goblin.gridZ;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist > maxDist) continue;

            const targetH = this.terrain.getTileHeight(goblin.gridX, goblin.gridZ);
            let score = dist;

            if (targetH > 8) {
                score += 20.0;
            }

            if (score < minScore) {
                minScore = score;
                nearest = goblin;
            }
        }
        this.targetGoblin = nearest;
    }

    getDistance(tx, tz) {
        let dx = Math.abs(this.gridX - tx);
        let dz = Math.abs(this.gridZ - tz);

        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        if (dx > logicalW / 2) dx = logicalW - dx;
        if (dz > logicalD / 2) dz = logicalD - dz;

        return Math.sqrt(dx * dx + dz * dz);
    }

    moveRandomly(time) {
        // Region-based Exploration (Replacing old random walk)

        // 1. Get Current Region
        const currentRegion = this.terrain.getRegion(this.gridX, this.gridZ);

        // 2. Determine Patrol Radius (Larger for Knights)
        const radius = (this.role === 'knight') ? 30 : 15;

        // 3. Find Valid Point in SAME Region
        const target = this.terrain.getRandomPointInRegion(currentRegion, this.gridX, this.gridZ, radius);

        if (target) {
            this.smartMove(target.x, target.z, time);
        } else {
            // Fallback: Just stand still or try small random step if stuck
            this.checkStuck();
        }
    }

    cleanIgnoredTargets(time) {
        if (!this.ignoredTargets) return;
        for (const [id, expiry] of this.ignoredTargets) {
            if (time > expiry) {
                this.ignoredTargets.delete(id);
            }
        }
    }


    // updatePosition inherited from Entity
    // getPositionForGrid inherited from Entity

    forceUnstuck() {
        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        let found = false;
        let attempts = 0;
        while (!found && attempts < 10) {
            const rx = Math.floor(Math.random() * 7) - 3;
            const rz = Math.floor(Math.random() * 7) - 3;
            if (rx === 0 && rz === 0) continue;

            let tx = this.gridX + rx;
            let tz = this.gridZ + rz;

            if (tx < 0) tx = logicalW - 1;
            if (tx >= logicalW) tx = 0;
            if (tz < 0) tz = logicalD - 1;
            if (tz >= logicalD) tz = 0;

            const h = this.terrain.getTileHeight(tx, tz);
            const cell = this.terrain.grid[tx][tz];

            // Fix: Check Building
            if (h > 0 && cell && !cell.hasBuilding) {
                const oldX = this.gridX;
                const oldZ = this.gridZ;
                this.gridX = tx;
                this.gridZ = tz;
                this.updatePosition();
                this.terrain.moveEntity(this, oldX, oldZ, tx, tz, 'unit');
                console.log(`Unit warped from ${oldX},${oldZ} to ${tx},${tz}`);
                found = true;
            }
            attempts++;
        }
    }

    migrate(time) {
        // Move to valid random point in SAME Region to avoid getting stuck
        const range = 20 + Math.random() * 20;

        // 1. Get Current Region
        let regionId = 1; // Default
        if (this.terrain.grid && this.terrain.grid[this.gridX] && this.terrain.grid[this.gridX][this.gridZ]) {
            regionId = this.terrain.grid[this.gridX][this.gridZ].regionId;
        }

        // 2. Find Point
        const target = this.terrain.getRandomPointInRegion(regionId, this.gridX, this.gridZ, range);

        if (target) {
            console.log(`Unit ${this.id} migrating to ${target.x},${target.z} (Region ${regionId})`);

            this.action = "Migrating";
            this.migrationTarget = { x: target.x, z: target.z };
            this.migrationTimer = 0;

            this.triggerMove(target.x, target.z, time);
        } else {
            console.warn(`Unit ${this.id} could not find migration target in Region ${regionId}. Staying Idle.`);
            this.action = 'Idle';
        }
    }

    tryBuildStructure(time) {
        // Restriction: Only Workers can build (User Request)
        if (this.role !== 'worker') return false;

        const logicalW = this.terrain.logicalWidth || 80;
        const logicalD = this.terrain.logicalDepth || 80;

        const x = this.gridX;
        const z = this.gridZ;
        const cell = this.terrain.grid[x][z];

        if (cell.hasBuilding) return;

        if (cell.height > 8) return;

        const houses = this.terrain.buildings.filter(b => b.type === 'house');
        const farms = this.terrain.buildings.filter(b => b.type === 'farm');
        const mansions = this.terrain.buildings.filter(b => b.type === 'mansion');

        const houseCount = houses.length;
        const farmCount = farms.length;
        const mansionCount = mansions.length;
        const totalPop = window.game ? window.game.totalPopulation : 0;

        // 2. Tower Logic (3x3) - Unlock at 3000
        const towers = this.terrain.buildings.filter(b => b.type === 'tower');
        const towerTarget = Math.floor(totalPop / 3000);

        if (towers.length < towerTarget) {
            if (this.terrain.checkFlatArea(x, z, 3)) {
                this.terrain.addBuilding('tower', x, z);
                this.moveRandomly(time);
                return true;
            }
        }

        // 3. Barracks Logic (3x3) - Replaces Mansion
        const barracks = this.terrain.buildings.filter(b => b.type === 'barracks');
        const barracksCount = barracks.length;
        // Logic: 1 Barracks per 1000 pop or just keep same ratio as old mansion?
        const barracksTarget = Math.floor(totalPop / 1000); // Same rarity as Mansion

        if (barracksCount < barracksTarget) {
            // Barracks is size 3 now
            if (this.terrain.checkFlatArea(x, z, 3)) {
                this.terrain.addBuilding('barracks', x, z);
                this.moveRandomly(time);
                return true;
            }
        }

        // 3. Farm Logic (2x2)
        const food = window.game ? window.game.resources.grain : 100;
        const lowFood = food < totalPop * 2;
        const lowFarms = farmCount < (houseCount / 2) + 1;

        if (lowFood || lowFarms) {
            if (Math.random() < 0.3) {
                if (this.terrain.checkFlatArea(x, z, 2)) {
                    if (this.buildFarm(time)) return true;
                }
            }
        }

        // 4. House Logic (Now 2x2)
        if (this.terrain.checkFlatArea(x, z, 2)) {
            if (cell.moisture > 0.8) {
                return false;
            }
            this.terrain.addBuilding('house', x, z);
            this.moveRandomly(time);
            return true;
        } else {
            return false;
        }
    }

    improveLand(time) {
        if (!this.terrain.grid[this.gridX] || !this.terrain.grid[this.gridX][this.gridZ]) return;

        const cell = this.terrain.grid[this.gridX][this.gridZ];
        const currentM = cell.moisture || 0.5;
        const targetM = 0.5;

        let diff = targetM - currentM;
        let change = diff * 0.4;

        if (Math.abs(change) < 0.1 && Math.abs(diff) > 0.01) {
            change = (diff > 0) ? 0.1 : -0.1;
        }

        if (Math.abs(change) > Math.abs(diff)) change = diff;

        this.terrain.modifyMoisture(this.gridX, this.gridZ, change);
        console.log(`Unit improved land at ${this.gridX},${this.gridZ}. Moisture ${currentM.toFixed(2)} -> ${(currentM + change).toFixed(2)}`);

        // Task Complete!
        if (this.targetRequest && this.game) {
            // Check if matches location (approx)
            if (Math.abs(this.targetRequest.x - this.gridX) < 2 && Math.abs(this.targetRequest.z - this.gridZ) < 2) {
                this.game.removeRequest(this.targetRequest);
                this.targetRequest = null;
            }
        }

        this.moveRandomly(time);
    }

    buildFarm(time) {
        let cell = null;
        if (this.terrain.grid[this.gridX] && this.terrain.grid[this.gridX][this.gridZ]) {
            cell = this.terrain.grid[this.gridX][this.gridZ];
        }

        if (cell) {
            const m = cell.moisture || 0.5;

            const diff = Math.abs(m - 0.5);
            let successChance = 1.0 - (diff * 2.5);
            if (successChance < 0) successChance = 0;

            if (Math.random() > successChance) {
                console.log(`Farm construction failed due to soil conditions (Moisture: ${m.toFixed(2)}, Chance: ${(successChance * 100).toFixed(0)}%). Improving Land.`);
                this.improveLand(time);
                return false;
            }
        }

        this.terrain.addBuilding('farm', this.gridX, this.gridZ);

        this.moveRandomly(time);
        return true;
    }

    static getCrossAssets() {
        if (!Unit.assets.geometries.crossV) {
            Unit.assets.geometries.crossV = new THREE.BoxGeometry(0.2, 1.0, 0.2);
            Unit.assets.geometries.crossH = new THREE.BoxGeometry(0.8, 0.2, 0.2);
        }
        return Unit.assets.geometries;
    }

    createCross() {
        const group = new THREE.Group();
        const GEO = Unit.getCrossAssets();

        const material = new THREE.MeshLambertMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 1.0
        });

        const vMesh = new THREE.Mesh(GEO.crossV, material);
        vMesh.position.y = 0.5;
        group.add(vMesh);

        const hMesh = new THREE.Mesh(GEO.crossH, material);
        hMesh.position.y = 0.7;
        group.add(hMesh);

        const pos = this.getPositionForGrid(this.gridX, this.gridZ);
        group.position.copy(pos);

        this.scene.add(group);
        this.crossMesh = group;
        this.deathTimer = 0;
    }

    updateDeathAnimation(deltaTime) {
        if (!this.crossMesh) return;

        if (isNaN(this.deathTimer)) this.deathTimer = 0;

        const safeDt = (deltaTime > 0) ? deltaTime : 0.016;
        this.deathTimer += safeDt;

        const duration = 3.0;

        if (this.deathTimer >= duration) {
            this.scene.remove(this.crossMesh);
            this.crossMesh.children.forEach(child => {
                if (child.material) child.material.dispose();
            });
            this.crossMesh = null;

            this.isFinished = true;
        } else {
            this.crossMesh.position.y += deltaTime * 1.0;
            const progress = this.deathTimer / duration;
            this.crossMesh.children.forEach(child => {
                child.material.opacity = 1.0 - progress;
            });
        }
    }

    static createWoodTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, 64, 64);

        ctx.strokeStyle = '#5D2906';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * 8 + Math.random() * 4);
            ctx.lineTo(64, i * 8 + Math.random() * 4);
            ctx.stroke();
        }

        return new THREE.CanvasTexture(canvas);
    }



    takeDamage(amount) {
        if (this.isDead) return;
        this.hp -= amount;

        // Ensure HP is finite
        if (isNaN(this.hp)) this.hp = 0;

        if (this.hp <= 0) {
            this.hp = 0;
            this.die();
        }
    }

    die() {
        if (this.isDead) return;
        this.isDead = true;

        this.createCross(); // Visual death

        console.log(`Unit ${this.id} (${this.role}) DIED. R.I.P.`);

        // Release Request if assigned
        if (this.targetRequest && this.game) {
            this.game.releaseRequest(this, this.targetRequest);
        }

        if (this.terrain && this.terrain.unregisterEntity) {
            this.terrain.unregisterEntity(this);
        }
    }

    static createRoofTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#A52A2A';
        ctx.fillRect(0, 0, 64, 64);

        ctx.fillStyle = '#800000';
        for (let y = 0; y < 64; y += 8) {
            for (let x = 0; x < 64; x += 8) {
                if ((x + y) % 16 === 0) ctx.fillRect(x, y, 7, 7);
            }
        }

        return new THREE.CanvasTexture(canvas);
    }

    serialize() {
        // Capture HomeBase coords if linked
        let hbx = undefined, hbz = undefined;
        if (this.homeBase && this.homeBase.userData) {
            hbx = this.homeBase.userData.gridX;
            hbz = this.homeBase.userData.gridZ;
        }

        return {
            gridX: this.gridX,
            gridZ: this.gridZ,
            age: this.age,
            lifespan: this.lifespan,
            isDead: this.isDead,
            isFinished: this.isFinished,
            isMoving: this.isMoving,
            targetX: this.targetX,
            targetZ: this.targetZ,
            moveStartTime: this.moveStartTime,
            startGridX: this.startGridX,
            startGridZ: this.startGridZ,
            targetGridX: this.targetGridX,
            targetGridZ: this.targetGridZ,
            isSpecial: this.isSpecial,
            role: this.role,
            // Stats
            hp: this.hp,
            maxHp: this.maxHp,
            damage: this.damage,
            xp: this.xp || 0,
            level: this.level || 1,
            name: this.name,
            // Squad Persistence
            homeBaseGridX: hbx,
            homeBaseGridZ: hbz,
            squadId: this.squadId, // Persist Squad
            // Request Persistence
            targetRequestId: (this.targetRequest) ? this.targetRequest.id : null
        };
    }

    dispose() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
            if (this.mesh.geometry) this.mesh.geometry.dispose();
            this.mesh = null;
        }

        if (this.crossMesh) {
            this.scene.remove(this.crossMesh);
            this.crossMesh.traverse(c => {
                if (c.geometry) c.geometry.dispose();
            });
            this.crossMesh = null;
        }

        this.terrain.unregisterEntity(this);
    }

    attemptPathfinding(time) {
        if (!this.terrain || !this.terrain.findPath) return;

        let tx, tz;

        if (this.targetGoblin) {
            tx = this.targetGoblin.gridX;
            tz = this.targetGoblin.gridZ;
        } else if (this.targetBuilding) {
            tx = this.targetBuilding.gridX;
            tz = this.targetBuilding.gridZ;
        } else if (this.targetRaidPoint) {
            tx = this.targetRaidPoint.x;
            tz = this.targetRaidPoint.z;
        } else if (this.migrationTarget) {
            tx = this.migrationTarget.x;
            tz = this.migrationTarget.z;
        } else {
            // No high level target known?
            return;
        }

        // Try to find path
        // Use a safe timeout to prevent spam if pathfinding blocked globally
        if (time - (this.lastPathAttempt || 0) < 2000) return;
        this.lastPathAttempt = time;

        const path = this.terrain.findPath(this.gridX, this.gridZ, tx, tz);

        if (path && path.length > 0) {
            console.log(`[Unit ${this.id}] Pathfinding SUCCESS! Found path of length ${path.length} to ${tx},${tz}`);
            this.path = path;
            this.stuckCount = 0; // Reset stuck since we found a solution
        } else {
            // console.warn(`[Unit ${this.id}] Pathfinding Failed.`);
            // ABORT TARGET if unreachable (Prevent sticking to coast)
            // Downgraded log to prevent spam
            if (this.id === 0 || Math.random() < 0.05) console.log(`[Unit ${this.id}] Pathfinding Failed (UNREACHABLE). Blocked by terrain/water? Aborting & Blacklisting.`);

            const now = (this.game) ? this.game.gameTotalTime : Date.now();

            // Blacklist targets
            if (this.targetUnit) this.ignoredTargets.set(this.targetUnit.id, now + 15000);
            if (this.targetGoblin) this.ignoredTargets.set(this.targetGoblin.id, now + 15000); // Also cover semantic logic
            if (this.targetBuilding) {
                const id = this.targetBuilding.userData ? (this.targetBuilding.userData.id || this.targetBuilding.id) : this.targetBuilding.id;
                if (id) this.ignoredTargets.set(id, now + 15000);
            }
            if (this.targetRaidPoint) {
                // Synthetic ID for coords
                this.ignoredTargets.set(`p_${this.targetRaidPoint.x}_${this.targetRaidPoint.z}`, now + 15000);
            }

            this.targetUnit = null;
            this.targetGoblin = null; // Ensure this is cleared too
            this.targetBuilding = null;
            this.targetRaidPoint = null;
            this.migrationTarget = null;
            this.targetRequest = null; // Drop job if unreachable
            this.path = null;
        }
    }

    static deserialize(data, scene, terrain) {
        const unit = new Unit(scene, terrain, data.gridX, data.gridZ, data.role || data.isSpecial, data.isSpecial);
        unit.age = data.age || 20;

        if (typeof data.lifespan === 'number' && data.lifespan > 0) {
            unit.lifespan = data.lifespan;
        }

        if (data.lifespan) unit.lifespan = data.lifespan;

        unit.isDead = data.isDead || false;
        unit.isDead = data.isDead || false;
        unit.isFinished = data.isFinished || false;

        // Restore Stats
        if (data.hp !== undefined) unit.hp = data.hp;
        if (data.maxHp !== undefined) unit.maxHp = data.maxHp;
        if (data.damage !== undefined) unit.damage = data.damage;
        if (data.xp !== undefined) unit.xp = data.xp;
        if (data.level !== undefined) unit.level = data.level;
        if (data.level !== undefined) unit.level = data.level;
        if (data.name !== undefined) unit.name = data.name;

        // Restore Squad Persistence (Temp storage for Game.js to use)
        if (data.homeBaseGridX !== undefined && data.homeBaseGridZ !== undefined) {
            unit.savedHomeBaseX = data.homeBaseGridX;
            unit.savedHomeBaseZ = data.homeBaseGridZ;
        }

        // Restore Squad ID (New Feature)
        if (data.squadId !== undefined) {
            unit.squadId = data.squadId;
        } else {
            unit.squadId = null; // Default for legacy saves
        }

        // Restore Request ID (Game.js will handle linking)
        if (data.targetRequestId) {
            unit.savedTargetRequestId = data.targetRequestId;
        }

        if (data.isMoving) {
            unit.isMoving = true;
            unit.targetX = data.targetX;
            unit.targetZ = data.targetZ;
            unit.moveStartTime = data.moveStartTime;
            unit.startGridX = data.startGridX;
            unit.startGridZ = data.startGridZ;
            unit.targetGridX = data.targetGridX;
            unit.targetGridZ = data.targetGridZ;

            // Recalculate moveDuration (it wasn't saved, but can be derived or re-calculated)
            // Or just rely on updateMovement to handle it?
            // updateMovement uses this.moveDuration.
            // moveDuration is usually distance * speed.
            // Let's re-calculate it to be safe.
            const dist = unit.getDistance(unit.targetGridX, unit.targetGridZ); // Wait, getDistance uses this.gridX/Z vs arg?
            // getDistance(tx,tz) uses current grid.
            // unit.gridX was restored.
            // Note: getDistance calculates from current grid.
            // But strict duration depends on START grid.
            let dx = Math.abs(unit.startGridX - unit.targetGridX);
            let dz = Math.abs(unit.startGridZ - unit.targetGridZ);

            // Wrap fix for deserialization too, though less critical for move duration unless very long warp
            const logicalW = unit.terrain.logicalWidth || 80;
            const logicalD = unit.terrain.logicalDepth || 80;
            if (dx > logicalW / 2) dx = logicalW - dx;
            if (dz > logicalD / 2) dz = logicalD - dz;

            const totalDist = Math.sqrt(dx * dx + dz * dz);
            unit.moveDuration = totalDist * 1000; // Assuming 1000ms per tile speed (standard)
            // If they are fast units, we might need to know speed.
            // Unit.js doesn't seem to have variable speed property (just moveDuration).
        }

        if (unit.isDead) {
            if (!unit.isFinished) {
                unit.createCross();
            }
        }

        return unit;
    }
}
