(function(){"use strict";let g=0,U=0,h=null,b=null;self.onmessage=function(o){const{type:n,payload:t,id:r}=o.data;switch(n){case"INIT":C(t);break;case"UPDATE_CHUNK":L(t);break;case"UPDATE_CELL":G(t);break;case"FIND_PATH":const d=performance.now();console.log(`[Worker] Unit ${t.unitId} FIND_PATH ReqID:${r} Start`);const p=q(t.sx,t.sz,t.ex,t.ez,t.maxSteps,t.unitId),l=performance.now()-d;console.log(`[Worker] Unit ${t.unitId} FIND_PATH ReqID:${r} Done in ${l.toFixed(2)}ms. Found:${!!p}`),self.postMessage({type:"PATH_RESULT",id:r,payload:p});break;case"DEBUG_GET_HEIGHT":const c=v(t.x,t.z);console.log(`[Worker DEBUG] Height at ${t.x},${t.z} is ${c} (Index: ${t.z*g+t.x})`);break;default:console.error("Unknown message type:",n)}};const v=(o,n)=>!h||o<0||o>=g||n<0||n>=U?-999:h[n*g+o];function C({w:o,h:n,data:t,moistureData:r}){g=o,U=n,h=new Int16Array(t),r?b=new Float32Array(r):b=new Float32Array(o*n).fill(.5),console.log(`[Worker] Grid Initialized: ${g}x${U} (with Moisture)`)}function G({x:o,z:n,h:t,m:r}){if(!h)return;const d=n*g+o;d>=0&&d<h.length&&(h[d]=t,r!==void 0&&b&&(b[d]=r))}function L({startX:o,startZ:n,w:t,h:r,data:d}){}function q(o,n,t,r,d=0,p=-1){if(!h)return null;const l=g,c=U;o=Math.round(o),n=Math.round(n),t=Math.round(t),r=Math.round(r),o=(o%l+l)%l,n=(n%c+c)%c,t=(t%l+l)%l,r=(r%c+c)%c;const x=(s,i)=>h[i*l+s],B=(s,i)=>b?b[i*l+s]:.5;if(x(o,n)<=0){let s=!1;for(let i=1;i<=4;i++){for(let e=-i;e<=i;e++){for(let u=-i;u<=i;u++){if(e===0&&u===0)continue;let $=(o+e+l)%l,k=(n+u+c)%c;if(x($,k)>0){o=$,n=k,s=!0;break}}if(s)break}if(s)break}if(!s)return console.log(`[Worker] Unit ${p} No Path: Start ${o},${n} is invalid and no valid neighbor found.`),null}if(x(t,r)<=0){let s=!1;for(let i=1;i<=4;i++){for(let e=-i;e<=i;e++){for(let u=-i;u<=i;u++){if(e===0&&u===0)continue;let $=(t+e+l)%l,k=(r+u+c)%c;if(x($,k)>0){t=$,r=k,s=!0;break}}if(s)break}if(s)break}if(!s)return console.log(`[Worker] Unit ${p} No Path: Target ${t},${r} is invalid and no valid neighbor found.`),null}const E={x:o,z:n,g:0,h:0,f:0,parent:null},H=[E],m=new Map;m.set(`${o},${n}`,E);const R=new Set;let N=0;const K=d>0?d:4e4;let W=E,_=1/0;try{for(;H.length>0;){if(N++,N>K){console.log(`[Worker] Unit ${p} MaxSteps Reached (${N}).`);const f=[];let a=W;for(;a;)f.push({x:a.x,z:a.z}),a=a.parent;return f.reverse()}let s=1/0,i=-1;for(let f=0;f<H.length;f++)H[f].f<s&&(s=H[f].f,i=f);const e=H.splice(i,1)[0];e.h<_&&(_=e.h,W=e);const u=`${e.x},${e.z}`;if(R.has(u))continue;if(R.add(u),m.delete(u),e.x===t&&e.z===r){const f=[];let a=e;for(;a;)f.push({x:a.x,z:a.z}),a=a.parent;return f.reverse()}const $=[{x:1,z:0,cost:1},{x:-1,z:0,cost:1},{x:0,z:1,cost:1},{x:0,z:-1,cost:1},{x:1,z:1,cost:1.414},{x:1,z:-1,cost:1.414},{x:-1,z:1,cost:1.414},{x:-1,z:-1,cost:1.414}],k=x(e.x,e.z);for(const f of $){let a=(e.x+f.x+l)%l,I=(e.z+f.z+c)%c;const P=`${a},${I}`;if(R.has(P))continue;const z=x(a,I);if(z<=0)continue;const F=Math.abs(z-k);if(F>3)continue;let A=.8*f.cost;z>8&&(A+=4),F>.1&&(A+=2),z<=8&&B(a,I)>.6&&(A+=1.2);const w=e.g+A;let M=m.get(P);if(M&&M.g<=w)continue;let y=Math.abs(a-t),T=Math.abs(I-r);y>l/2&&(y=l-y),T>c/2&&(T=c-T);const S=Math.sqrt(y*y+T*T)*1;if(M)M.g=w,M.f=w+S,M.parent=e;else{const D={x:a,z:I,g:w,h:S,f:w+S,parent:e};H.push(D),m.set(P,D)}}}}catch(s){return console.error(`[Worker] Unit ${p} CRITICAL ERROR in Pathfinding:`,s),self.postMessage({type:"PATH_ERROR",id,payload:{error:s.message}}),null}return null}})();
